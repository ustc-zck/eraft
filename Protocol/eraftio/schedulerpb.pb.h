// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: schedulerpb.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_schedulerpb_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_schedulerpb_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "metapb.pb.h"
#include "eraftpb.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_schedulerpb_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_schedulerpb_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[52]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_schedulerpb_2eproto;
namespace schedulerpb {
class AllocIDRequest;
class AllocIDRequestDefaultTypeInternal;
extern AllocIDRequestDefaultTypeInternal _AllocIDRequest_default_instance_;
class AllocIDResponse;
class AllocIDResponseDefaultTypeInternal;
extern AllocIDResponseDefaultTypeInternal _AllocIDResponse_default_instance_;
class AskSplitRequest;
class AskSplitRequestDefaultTypeInternal;
extern AskSplitRequestDefaultTypeInternal _AskSplitRequest_default_instance_;
class AskSplitResponse;
class AskSplitResponseDefaultTypeInternal;
extern AskSplitResponseDefaultTypeInternal _AskSplitResponse_default_instance_;
class BootstrapRequest;
class BootstrapRequestDefaultTypeInternal;
extern BootstrapRequestDefaultTypeInternal _BootstrapRequest_default_instance_;
class BootstrapResponse;
class BootstrapResponseDefaultTypeInternal;
extern BootstrapResponseDefaultTypeInternal _BootstrapResponse_default_instance_;
class ChangePeer;
class ChangePeerDefaultTypeInternal;
extern ChangePeerDefaultTypeInternal _ChangePeer_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class GetAllStoresRequest;
class GetAllStoresRequestDefaultTypeInternal;
extern GetAllStoresRequestDefaultTypeInternal _GetAllStoresRequest_default_instance_;
class GetAllStoresResponse;
class GetAllStoresResponseDefaultTypeInternal;
extern GetAllStoresResponseDefaultTypeInternal _GetAllStoresResponse_default_instance_;
class GetClusterConfigRequest;
class GetClusterConfigRequestDefaultTypeInternal;
extern GetClusterConfigRequestDefaultTypeInternal _GetClusterConfigRequest_default_instance_;
class GetClusterConfigResponse;
class GetClusterConfigResponseDefaultTypeInternal;
extern GetClusterConfigResponseDefaultTypeInternal _GetClusterConfigResponse_default_instance_;
class GetGCSafePointRequest;
class GetGCSafePointRequestDefaultTypeInternal;
extern GetGCSafePointRequestDefaultTypeInternal _GetGCSafePointRequest_default_instance_;
class GetGCSafePointResponse;
class GetGCSafePointResponseDefaultTypeInternal;
extern GetGCSafePointResponseDefaultTypeInternal _GetGCSafePointResponse_default_instance_;
class GetMembersRequest;
class GetMembersRequestDefaultTypeInternal;
extern GetMembersRequestDefaultTypeInternal _GetMembersRequest_default_instance_;
class GetMembersResponse;
class GetMembersResponseDefaultTypeInternal;
extern GetMembersResponseDefaultTypeInternal _GetMembersResponse_default_instance_;
class GetOperatorRequest;
class GetOperatorRequestDefaultTypeInternal;
extern GetOperatorRequestDefaultTypeInternal _GetOperatorRequest_default_instance_;
class GetOperatorResponse;
class GetOperatorResponseDefaultTypeInternal;
extern GetOperatorResponseDefaultTypeInternal _GetOperatorResponse_default_instance_;
class GetRegionByIDRequest;
class GetRegionByIDRequestDefaultTypeInternal;
extern GetRegionByIDRequestDefaultTypeInternal _GetRegionByIDRequest_default_instance_;
class GetRegionRequest;
class GetRegionRequestDefaultTypeInternal;
extern GetRegionRequestDefaultTypeInternal _GetRegionRequest_default_instance_;
class GetRegionResponse;
class GetRegionResponseDefaultTypeInternal;
extern GetRegionResponseDefaultTypeInternal _GetRegionResponse_default_instance_;
class GetStoreRequest;
class GetStoreRequestDefaultTypeInternal;
extern GetStoreRequestDefaultTypeInternal _GetStoreRequest_default_instance_;
class GetStoreResponse;
class GetStoreResponseDefaultTypeInternal;
extern GetStoreResponseDefaultTypeInternal _GetStoreResponse_default_instance_;
class IsBootstrappedRequest;
class IsBootstrappedRequestDefaultTypeInternal;
extern IsBootstrappedRequestDefaultTypeInternal _IsBootstrappedRequest_default_instance_;
class IsBootstrappedResponse;
class IsBootstrappedResponseDefaultTypeInternal;
extern IsBootstrappedResponseDefaultTypeInternal _IsBootstrappedResponse_default_instance_;
class Member;
class MemberDefaultTypeInternal;
extern MemberDefaultTypeInternal _Member_default_instance_;
class PutClusterConfigRequest;
class PutClusterConfigRequestDefaultTypeInternal;
extern PutClusterConfigRequestDefaultTypeInternal _PutClusterConfigRequest_default_instance_;
class PutClusterConfigResponse;
class PutClusterConfigResponseDefaultTypeInternal;
extern PutClusterConfigResponseDefaultTypeInternal _PutClusterConfigResponse_default_instance_;
class PutStoreRequest;
class PutStoreRequestDefaultTypeInternal;
extern PutStoreRequestDefaultTypeInternal _PutStoreRequest_default_instance_;
class PutStoreResponse;
class PutStoreResponseDefaultTypeInternal;
extern PutStoreResponseDefaultTypeInternal _PutStoreResponse_default_instance_;
class RecordPair;
class RecordPairDefaultTypeInternal;
extern RecordPairDefaultTypeInternal _RecordPair_default_instance_;
class RegionHeartbeatRequest;
class RegionHeartbeatRequestDefaultTypeInternal;
extern RegionHeartbeatRequestDefaultTypeInternal _RegionHeartbeatRequest_default_instance_;
class RegionHeartbeatResponse;
class RegionHeartbeatResponseDefaultTypeInternal;
extern RegionHeartbeatResponseDefaultTypeInternal _RegionHeartbeatResponse_default_instance_;
class ReportSplitRequest;
class ReportSplitRequestDefaultTypeInternal;
extern ReportSplitRequestDefaultTypeInternal _ReportSplitRequest_default_instance_;
class ReportSplitResponse;
class ReportSplitResponseDefaultTypeInternal;
extern ReportSplitResponseDefaultTypeInternal _ReportSplitResponse_default_instance_;
class RequestHeader;
class RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class ResponseHeader;
class ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
class ScanRegionsRequest;
class ScanRegionsRequestDefaultTypeInternal;
extern ScanRegionsRequestDefaultTypeInternal _ScanRegionsRequest_default_instance_;
class ScanRegionsResponse;
class ScanRegionsResponseDefaultTypeInternal;
extern ScanRegionsResponseDefaultTypeInternal _ScanRegionsResponse_default_instance_;
class ScatterRegionRequest;
class ScatterRegionRequestDefaultTypeInternal;
extern ScatterRegionRequestDefaultTypeInternal _ScatterRegionRequest_default_instance_;
class ScatterRegionResponse;
class ScatterRegionResponseDefaultTypeInternal;
extern ScatterRegionResponseDefaultTypeInternal _ScatterRegionResponse_default_instance_;
class SplitID;
class SplitIDDefaultTypeInternal;
extern SplitIDDefaultTypeInternal _SplitID_default_instance_;
class StoreHeartbeatRequest;
class StoreHeartbeatRequestDefaultTypeInternal;
extern StoreHeartbeatRequestDefaultTypeInternal _StoreHeartbeatRequest_default_instance_;
class StoreHeartbeatResponse;
class StoreHeartbeatResponseDefaultTypeInternal;
extern StoreHeartbeatResponseDefaultTypeInternal _StoreHeartbeatResponse_default_instance_;
class StoreStats;
class StoreStatsDefaultTypeInternal;
extern StoreStatsDefaultTypeInternal _StoreStats_default_instance_;
class TimeInterval;
class TimeIntervalDefaultTypeInternal;
extern TimeIntervalDefaultTypeInternal _TimeInterval_default_instance_;
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
class TransferLeader;
class TransferLeaderDefaultTypeInternal;
extern TransferLeaderDefaultTypeInternal _TransferLeader_default_instance_;
class TsoRequest;
class TsoRequestDefaultTypeInternal;
extern TsoRequestDefaultTypeInternal _TsoRequest_default_instance_;
class TsoResponse;
class TsoResponseDefaultTypeInternal;
extern TsoResponseDefaultTypeInternal _TsoResponse_default_instance_;
class UpdateGCSafePointRequest;
class UpdateGCSafePointRequestDefaultTypeInternal;
extern UpdateGCSafePointRequestDefaultTypeInternal _UpdateGCSafePointRequest_default_instance_;
class UpdateGCSafePointResponse;
class UpdateGCSafePointResponseDefaultTypeInternal;
extern UpdateGCSafePointResponseDefaultTypeInternal _UpdateGCSafePointResponse_default_instance_;
}  // namespace schedulerpb
PROTOBUF_NAMESPACE_OPEN
template<> ::schedulerpb::AllocIDRequest* Arena::CreateMaybeMessage<::schedulerpb::AllocIDRequest>(Arena*);
template<> ::schedulerpb::AllocIDResponse* Arena::CreateMaybeMessage<::schedulerpb::AllocIDResponse>(Arena*);
template<> ::schedulerpb::AskSplitRequest* Arena::CreateMaybeMessage<::schedulerpb::AskSplitRequest>(Arena*);
template<> ::schedulerpb::AskSplitResponse* Arena::CreateMaybeMessage<::schedulerpb::AskSplitResponse>(Arena*);
template<> ::schedulerpb::BootstrapRequest* Arena::CreateMaybeMessage<::schedulerpb::BootstrapRequest>(Arena*);
template<> ::schedulerpb::BootstrapResponse* Arena::CreateMaybeMessage<::schedulerpb::BootstrapResponse>(Arena*);
template<> ::schedulerpb::ChangePeer* Arena::CreateMaybeMessage<::schedulerpb::ChangePeer>(Arena*);
template<> ::schedulerpb::Error* Arena::CreateMaybeMessage<::schedulerpb::Error>(Arena*);
template<> ::schedulerpb::GetAllStoresRequest* Arena::CreateMaybeMessage<::schedulerpb::GetAllStoresRequest>(Arena*);
template<> ::schedulerpb::GetAllStoresResponse* Arena::CreateMaybeMessage<::schedulerpb::GetAllStoresResponse>(Arena*);
template<> ::schedulerpb::GetClusterConfigRequest* Arena::CreateMaybeMessage<::schedulerpb::GetClusterConfigRequest>(Arena*);
template<> ::schedulerpb::GetClusterConfigResponse* Arena::CreateMaybeMessage<::schedulerpb::GetClusterConfigResponse>(Arena*);
template<> ::schedulerpb::GetGCSafePointRequest* Arena::CreateMaybeMessage<::schedulerpb::GetGCSafePointRequest>(Arena*);
template<> ::schedulerpb::GetGCSafePointResponse* Arena::CreateMaybeMessage<::schedulerpb::GetGCSafePointResponse>(Arena*);
template<> ::schedulerpb::GetMembersRequest* Arena::CreateMaybeMessage<::schedulerpb::GetMembersRequest>(Arena*);
template<> ::schedulerpb::GetMembersResponse* Arena::CreateMaybeMessage<::schedulerpb::GetMembersResponse>(Arena*);
template<> ::schedulerpb::GetOperatorRequest* Arena::CreateMaybeMessage<::schedulerpb::GetOperatorRequest>(Arena*);
template<> ::schedulerpb::GetOperatorResponse* Arena::CreateMaybeMessage<::schedulerpb::GetOperatorResponse>(Arena*);
template<> ::schedulerpb::GetRegionByIDRequest* Arena::CreateMaybeMessage<::schedulerpb::GetRegionByIDRequest>(Arena*);
template<> ::schedulerpb::GetRegionRequest* Arena::CreateMaybeMessage<::schedulerpb::GetRegionRequest>(Arena*);
template<> ::schedulerpb::GetRegionResponse* Arena::CreateMaybeMessage<::schedulerpb::GetRegionResponse>(Arena*);
template<> ::schedulerpb::GetStoreRequest* Arena::CreateMaybeMessage<::schedulerpb::GetStoreRequest>(Arena*);
template<> ::schedulerpb::GetStoreResponse* Arena::CreateMaybeMessage<::schedulerpb::GetStoreResponse>(Arena*);
template<> ::schedulerpb::IsBootstrappedRequest* Arena::CreateMaybeMessage<::schedulerpb::IsBootstrappedRequest>(Arena*);
template<> ::schedulerpb::IsBootstrappedResponse* Arena::CreateMaybeMessage<::schedulerpb::IsBootstrappedResponse>(Arena*);
template<> ::schedulerpb::Member* Arena::CreateMaybeMessage<::schedulerpb::Member>(Arena*);
template<> ::schedulerpb::PutClusterConfigRequest* Arena::CreateMaybeMessage<::schedulerpb::PutClusterConfigRequest>(Arena*);
template<> ::schedulerpb::PutClusterConfigResponse* Arena::CreateMaybeMessage<::schedulerpb::PutClusterConfigResponse>(Arena*);
template<> ::schedulerpb::PutStoreRequest* Arena::CreateMaybeMessage<::schedulerpb::PutStoreRequest>(Arena*);
template<> ::schedulerpb::PutStoreResponse* Arena::CreateMaybeMessage<::schedulerpb::PutStoreResponse>(Arena*);
template<> ::schedulerpb::RecordPair* Arena::CreateMaybeMessage<::schedulerpb::RecordPair>(Arena*);
template<> ::schedulerpb::RegionHeartbeatRequest* Arena::CreateMaybeMessage<::schedulerpb::RegionHeartbeatRequest>(Arena*);
template<> ::schedulerpb::RegionHeartbeatResponse* Arena::CreateMaybeMessage<::schedulerpb::RegionHeartbeatResponse>(Arena*);
template<> ::schedulerpb::ReportSplitRequest* Arena::CreateMaybeMessage<::schedulerpb::ReportSplitRequest>(Arena*);
template<> ::schedulerpb::ReportSplitResponse* Arena::CreateMaybeMessage<::schedulerpb::ReportSplitResponse>(Arena*);
template<> ::schedulerpb::RequestHeader* Arena::CreateMaybeMessage<::schedulerpb::RequestHeader>(Arena*);
template<> ::schedulerpb::ResponseHeader* Arena::CreateMaybeMessage<::schedulerpb::ResponseHeader>(Arena*);
template<> ::schedulerpb::ScanRegionsRequest* Arena::CreateMaybeMessage<::schedulerpb::ScanRegionsRequest>(Arena*);
template<> ::schedulerpb::ScanRegionsResponse* Arena::CreateMaybeMessage<::schedulerpb::ScanRegionsResponse>(Arena*);
template<> ::schedulerpb::ScatterRegionRequest* Arena::CreateMaybeMessage<::schedulerpb::ScatterRegionRequest>(Arena*);
template<> ::schedulerpb::ScatterRegionResponse* Arena::CreateMaybeMessage<::schedulerpb::ScatterRegionResponse>(Arena*);
template<> ::schedulerpb::SplitID* Arena::CreateMaybeMessage<::schedulerpb::SplitID>(Arena*);
template<> ::schedulerpb::StoreHeartbeatRequest* Arena::CreateMaybeMessage<::schedulerpb::StoreHeartbeatRequest>(Arena*);
template<> ::schedulerpb::StoreHeartbeatResponse* Arena::CreateMaybeMessage<::schedulerpb::StoreHeartbeatResponse>(Arena*);
template<> ::schedulerpb::StoreStats* Arena::CreateMaybeMessage<::schedulerpb::StoreStats>(Arena*);
template<> ::schedulerpb::TimeInterval* Arena::CreateMaybeMessage<::schedulerpb::TimeInterval>(Arena*);
template<> ::schedulerpb::Timestamp* Arena::CreateMaybeMessage<::schedulerpb::Timestamp>(Arena*);
template<> ::schedulerpb::TransferLeader* Arena::CreateMaybeMessage<::schedulerpb::TransferLeader>(Arena*);
template<> ::schedulerpb::TsoRequest* Arena::CreateMaybeMessage<::schedulerpb::TsoRequest>(Arena*);
template<> ::schedulerpb::TsoResponse* Arena::CreateMaybeMessage<::schedulerpb::TsoResponse>(Arena*);
template<> ::schedulerpb::UpdateGCSafePointRequest* Arena::CreateMaybeMessage<::schedulerpb::UpdateGCSafePointRequest>(Arena*);
template<> ::schedulerpb::UpdateGCSafePointResponse* Arena::CreateMaybeMessage<::schedulerpb::UpdateGCSafePointResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace schedulerpb {

enum ErrorType : int {
  OK = 0,
  UNKNOWN = 1,
  NOT_BOOTSTRAPPED = 2,
  STORE_TOMBSTONE = 3,
  ALREADY_BOOTSTRAPPED = 4,
  INCOMPATIBLE_VERSION = 5,
  REGION_NOT_FOUND = 6,
  ErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ErrorType_IsValid(int value);
constexpr ErrorType ErrorType_MIN = OK;
constexpr ErrorType ErrorType_MAX = REGION_NOT_FOUND;
constexpr int ErrorType_ARRAYSIZE = ErrorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorType_descriptor();
template<typename T>
inline const std::string& ErrorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ErrorType_descriptor(), enum_t_value);
}
inline bool ErrorType_Parse(
    const std::string& name, ErrorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ErrorType>(
    ErrorType_descriptor(), name, value);
}
enum OperatorStatus : int {
  SUCCESS = 0,
  TIMEOUT = 1,
  CANCEL = 2,
  REPLACE = 3,
  RUNNING = 4,
  OperatorStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OperatorStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OperatorStatus_IsValid(int value);
constexpr OperatorStatus OperatorStatus_MIN = SUCCESS;
constexpr OperatorStatus OperatorStatus_MAX = RUNNING;
constexpr int OperatorStatus_ARRAYSIZE = OperatorStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OperatorStatus_descriptor();
template<typename T>
inline const std::string& OperatorStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OperatorStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OperatorStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OperatorStatus_descriptor(), enum_t_value);
}
inline bool OperatorStatus_Parse(
    const std::string& name, OperatorStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OperatorStatus>(
    OperatorStatus_descriptor(), name, value);
}
// ===================================================================

class RequestHeader :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.RequestHeader) */ {
 public:
  RequestHeader();
  virtual ~RequestHeader();

  RequestHeader(const RequestHeader& from);
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RequestHeader* other);
  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestHeader* New() const final {
    return CreateMaybeMessage<RequestHeader>(nullptr);
  }

  RequestHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestHeader& from);
  void MergeFrom(const RequestHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.RequestHeader";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 cluster_id = 1;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint64 cluster_id() const;
  void set_cluster_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.RequestHeader)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 cluster_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class ResponseHeader :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.ResponseHeader) */ {
 public:
  ResponseHeader();
  virtual ~ResponseHeader();

  ResponseHeader(const ResponseHeader& from);
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResponseHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ResponseHeader* other);
  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseHeader* New() const final {
    return CreateMaybeMessage<ResponseHeader>(nullptr);
  }

  ResponseHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResponseHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResponseHeader& from);
  void MergeFrom(const ResponseHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.ResponseHeader";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::schedulerpb::Error& error() const;
  ::schedulerpb::Error* release_error();
  ::schedulerpb::Error* mutable_error();
  void set_allocated_error(::schedulerpb::Error* error);

  // uint64 cluster_id = 1;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint64 cluster_id() const;
  void set_cluster_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.ResponseHeader)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::Error* error_;
  ::PROTOBUF_NAMESPACE_ID::uint64 cluster_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class Error :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Error& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Error* other);
  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const final {
    return CreateMaybeMessage<Error>(nullptr);
  }

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.Error";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);

  // .schedulerpb.ErrorType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::schedulerpb::ErrorType type() const;
  void set_type(::schedulerpb::ErrorType value);

  // @@protoc_insertion_point(class_scope:schedulerpb.Error)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class TsoRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.TsoRequest) */ {
 public:
  TsoRequest();
  virtual ~TsoRequest();

  TsoRequest(const TsoRequest& from);
  TsoRequest(TsoRequest&& from) noexcept
    : TsoRequest() {
    *this = ::std::move(from);
  }

  inline TsoRequest& operator=(const TsoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TsoRequest& operator=(TsoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TsoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TsoRequest* internal_default_instance() {
    return reinterpret_cast<const TsoRequest*>(
               &_TsoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TsoRequest* other);
  friend void swap(TsoRequest& a, TsoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TsoRequest* New() const final {
    return CreateMaybeMessage<TsoRequest>(nullptr);
  }

  TsoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TsoRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TsoRequest& from);
  void MergeFrom(const TsoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TsoRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.TsoRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // uint32 count = 2;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.TsoRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::RequestHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::uint32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class Timestamp :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.Timestamp) */ {
 public:
  Timestamp();
  virtual ~Timestamp();

  Timestamp(const Timestamp& from);
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Timestamp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Timestamp* other);
  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Timestamp* New() const final {
    return CreateMaybeMessage<Timestamp>(nullptr);
  }

  Timestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Timestamp>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Timestamp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.Timestamp";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 physical = 1;
  void clear_physical();
  static const int kPhysicalFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int64 physical() const;
  void set_physical(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int64 logical = 2;
  void clear_logical();
  static const int kLogicalFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int64 logical() const;
  void set_logical(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.Timestamp)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 physical_;
  ::PROTOBUF_NAMESPACE_ID::int64 logical_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class TsoResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.TsoResponse) */ {
 public:
  TsoResponse();
  virtual ~TsoResponse();

  TsoResponse(const TsoResponse& from);
  TsoResponse(TsoResponse&& from) noexcept
    : TsoResponse() {
    *this = ::std::move(from);
  }

  inline TsoResponse& operator=(const TsoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TsoResponse& operator=(TsoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TsoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TsoResponse* internal_default_instance() {
    return reinterpret_cast<const TsoResponse*>(
               &_TsoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(TsoResponse* other);
  friend void swap(TsoResponse& a, TsoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TsoResponse* New() const final {
    return CreateMaybeMessage<TsoResponse>(nullptr);
  }

  TsoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TsoResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TsoResponse& from);
  void MergeFrom(const TsoResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TsoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.TsoResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // .schedulerpb.Timestamp timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  const ::schedulerpb::Timestamp& timestamp() const;
  ::schedulerpb::Timestamp* release_timestamp();
  ::schedulerpb::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::schedulerpb::Timestamp* timestamp);

  // uint32 count = 2;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.TsoResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::ResponseHeader* header_;
  ::schedulerpb::Timestamp* timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint32 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class BootstrapRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.BootstrapRequest) */ {
 public:
  BootstrapRequest();
  virtual ~BootstrapRequest();

  BootstrapRequest(const BootstrapRequest& from);
  BootstrapRequest(BootstrapRequest&& from) noexcept
    : BootstrapRequest() {
    *this = ::std::move(from);
  }

  inline BootstrapRequest& operator=(const BootstrapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BootstrapRequest& operator=(BootstrapRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BootstrapRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BootstrapRequest* internal_default_instance() {
    return reinterpret_cast<const BootstrapRequest*>(
               &_BootstrapRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(BootstrapRequest* other);
  friend void swap(BootstrapRequest& a, BootstrapRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BootstrapRequest* New() const final {
    return CreateMaybeMessage<BootstrapRequest>(nullptr);
  }

  BootstrapRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BootstrapRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BootstrapRequest& from);
  void MergeFrom(const BootstrapRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BootstrapRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.BootstrapRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // .metapb.Store store = 2;
  bool has_store() const;
  void clear_store();
  static const int kStoreFieldNumber = 2;
  const ::metapb::Store& store() const;
  ::metapb::Store* release_store();
  ::metapb::Store* mutable_store();
  void set_allocated_store(::metapb::Store* store);

  // @@protoc_insertion_point(class_scope:schedulerpb.BootstrapRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::RequestHeader* header_;
  ::metapb::Store* store_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class BootstrapResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.BootstrapResponse) */ {
 public:
  BootstrapResponse();
  virtual ~BootstrapResponse();

  BootstrapResponse(const BootstrapResponse& from);
  BootstrapResponse(BootstrapResponse&& from) noexcept
    : BootstrapResponse() {
    *this = ::std::move(from);
  }

  inline BootstrapResponse& operator=(const BootstrapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BootstrapResponse& operator=(BootstrapResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BootstrapResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BootstrapResponse* internal_default_instance() {
    return reinterpret_cast<const BootstrapResponse*>(
               &_BootstrapResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(BootstrapResponse* other);
  friend void swap(BootstrapResponse& a, BootstrapResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BootstrapResponse* New() const final {
    return CreateMaybeMessage<BootstrapResponse>(nullptr);
  }

  BootstrapResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BootstrapResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BootstrapResponse& from);
  void MergeFrom(const BootstrapResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BootstrapResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.BootstrapResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:schedulerpb.BootstrapResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class IsBootstrappedRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.IsBootstrappedRequest) */ {
 public:
  IsBootstrappedRequest();
  virtual ~IsBootstrappedRequest();

  IsBootstrappedRequest(const IsBootstrappedRequest& from);
  IsBootstrappedRequest(IsBootstrappedRequest&& from) noexcept
    : IsBootstrappedRequest() {
    *this = ::std::move(from);
  }

  inline IsBootstrappedRequest& operator=(const IsBootstrappedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsBootstrappedRequest& operator=(IsBootstrappedRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IsBootstrappedRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsBootstrappedRequest* internal_default_instance() {
    return reinterpret_cast<const IsBootstrappedRequest*>(
               &_IsBootstrappedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(IsBootstrappedRequest* other);
  friend void swap(IsBootstrappedRequest& a, IsBootstrappedRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsBootstrappedRequest* New() const final {
    return CreateMaybeMessage<IsBootstrappedRequest>(nullptr);
  }

  IsBootstrappedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IsBootstrappedRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IsBootstrappedRequest& from);
  void MergeFrom(const IsBootstrappedRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsBootstrappedRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.IsBootstrappedRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:schedulerpb.IsBootstrappedRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class IsBootstrappedResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.IsBootstrappedResponse) */ {
 public:
  IsBootstrappedResponse();
  virtual ~IsBootstrappedResponse();

  IsBootstrappedResponse(const IsBootstrappedResponse& from);
  IsBootstrappedResponse(IsBootstrappedResponse&& from) noexcept
    : IsBootstrappedResponse() {
    *this = ::std::move(from);
  }

  inline IsBootstrappedResponse& operator=(const IsBootstrappedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsBootstrappedResponse& operator=(IsBootstrappedResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const IsBootstrappedResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsBootstrappedResponse* internal_default_instance() {
    return reinterpret_cast<const IsBootstrappedResponse*>(
               &_IsBootstrappedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(IsBootstrappedResponse* other);
  friend void swap(IsBootstrappedResponse& a, IsBootstrappedResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsBootstrappedResponse* New() const final {
    return CreateMaybeMessage<IsBootstrappedResponse>(nullptr);
  }

  IsBootstrappedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IsBootstrappedResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const IsBootstrappedResponse& from);
  void MergeFrom(const IsBootstrappedResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsBootstrappedResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.IsBootstrappedResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // bool bootstrapped = 2;
  void clear_bootstrapped();
  static const int kBootstrappedFieldNumber = 2;
  bool bootstrapped() const;
  void set_bootstrapped(bool value);

  // @@protoc_insertion_point(class_scope:schedulerpb.IsBootstrappedResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::ResponseHeader* header_;
  bool bootstrapped_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class AllocIDRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.AllocIDRequest) */ {
 public:
  AllocIDRequest();
  virtual ~AllocIDRequest();

  AllocIDRequest(const AllocIDRequest& from);
  AllocIDRequest(AllocIDRequest&& from) noexcept
    : AllocIDRequest() {
    *this = ::std::move(from);
  }

  inline AllocIDRequest& operator=(const AllocIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocIDRequest& operator=(AllocIDRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AllocIDRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllocIDRequest* internal_default_instance() {
    return reinterpret_cast<const AllocIDRequest*>(
               &_AllocIDRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(AllocIDRequest* other);
  friend void swap(AllocIDRequest& a, AllocIDRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AllocIDRequest* New() const final {
    return CreateMaybeMessage<AllocIDRequest>(nullptr);
  }

  AllocIDRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllocIDRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AllocIDRequest& from);
  void MergeFrom(const AllocIDRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllocIDRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.AllocIDRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:schedulerpb.AllocIDRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class AllocIDResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.AllocIDResponse) */ {
 public:
  AllocIDResponse();
  virtual ~AllocIDResponse();

  AllocIDResponse(const AllocIDResponse& from);
  AllocIDResponse(AllocIDResponse&& from) noexcept
    : AllocIDResponse() {
    *this = ::std::move(from);
  }

  inline AllocIDResponse& operator=(const AllocIDResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocIDResponse& operator=(AllocIDResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AllocIDResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllocIDResponse* internal_default_instance() {
    return reinterpret_cast<const AllocIDResponse*>(
               &_AllocIDResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(AllocIDResponse* other);
  friend void swap(AllocIDResponse& a, AllocIDResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AllocIDResponse* New() const final {
    return CreateMaybeMessage<AllocIDResponse>(nullptr);
  }

  AllocIDResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AllocIDResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AllocIDResponse& from);
  void MergeFrom(const AllocIDResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllocIDResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.AllocIDResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // uint64 id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.AllocIDResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::ResponseHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class GetStoreRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.GetStoreRequest) */ {
 public:
  GetStoreRequest();
  virtual ~GetStoreRequest();

  GetStoreRequest(const GetStoreRequest& from);
  GetStoreRequest(GetStoreRequest&& from) noexcept
    : GetStoreRequest() {
    *this = ::std::move(from);
  }

  inline GetStoreRequest& operator=(const GetStoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStoreRequest& operator=(GetStoreRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetStoreRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetStoreRequest* internal_default_instance() {
    return reinterpret_cast<const GetStoreRequest*>(
               &_GetStoreRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(GetStoreRequest* other);
  friend void swap(GetStoreRequest& a, GetStoreRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetStoreRequest* New() const final {
    return CreateMaybeMessage<GetStoreRequest>(nullptr);
  }

  GetStoreRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetStoreRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetStoreRequest& from);
  void MergeFrom(const GetStoreRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStoreRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.GetStoreRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // uint64 store_id = 2;
  void clear_store_id();
  static const int kStoreIdFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint64 store_id() const;
  void set_store_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.GetStoreRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::RequestHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::uint64 store_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class GetStoreResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.GetStoreResponse) */ {
 public:
  GetStoreResponse();
  virtual ~GetStoreResponse();

  GetStoreResponse(const GetStoreResponse& from);
  GetStoreResponse(GetStoreResponse&& from) noexcept
    : GetStoreResponse() {
    *this = ::std::move(from);
  }

  inline GetStoreResponse& operator=(const GetStoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStoreResponse& operator=(GetStoreResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetStoreResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetStoreResponse* internal_default_instance() {
    return reinterpret_cast<const GetStoreResponse*>(
               &_GetStoreResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(GetStoreResponse* other);
  friend void swap(GetStoreResponse& a, GetStoreResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetStoreResponse* New() const final {
    return CreateMaybeMessage<GetStoreResponse>(nullptr);
  }

  GetStoreResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetStoreResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetStoreResponse& from);
  void MergeFrom(const GetStoreResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStoreResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.GetStoreResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // .metapb.Store store = 2;
  bool has_store() const;
  void clear_store();
  static const int kStoreFieldNumber = 2;
  const ::metapb::Store& store() const;
  ::metapb::Store* release_store();
  ::metapb::Store* mutable_store();
  void set_allocated_store(::metapb::Store* store);

  // .schedulerpb.StoreStats stats = 3;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 3;
  const ::schedulerpb::StoreStats& stats() const;
  ::schedulerpb::StoreStats* release_stats();
  ::schedulerpb::StoreStats* mutable_stats();
  void set_allocated_stats(::schedulerpb::StoreStats* stats);

  // @@protoc_insertion_point(class_scope:schedulerpb.GetStoreResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::ResponseHeader* header_;
  ::metapb::Store* store_;
  ::schedulerpb::StoreStats* stats_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class PutStoreRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.PutStoreRequest) */ {
 public:
  PutStoreRequest();
  virtual ~PutStoreRequest();

  PutStoreRequest(const PutStoreRequest& from);
  PutStoreRequest(PutStoreRequest&& from) noexcept
    : PutStoreRequest() {
    *this = ::std::move(from);
  }

  inline PutStoreRequest& operator=(const PutStoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutStoreRequest& operator=(PutStoreRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PutStoreRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutStoreRequest* internal_default_instance() {
    return reinterpret_cast<const PutStoreRequest*>(
               &_PutStoreRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(PutStoreRequest* other);
  friend void swap(PutStoreRequest& a, PutStoreRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutStoreRequest* New() const final {
    return CreateMaybeMessage<PutStoreRequest>(nullptr);
  }

  PutStoreRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PutStoreRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PutStoreRequest& from);
  void MergeFrom(const PutStoreRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutStoreRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.PutStoreRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // .metapb.Store store = 2;
  bool has_store() const;
  void clear_store();
  static const int kStoreFieldNumber = 2;
  const ::metapb::Store& store() const;
  ::metapb::Store* release_store();
  ::metapb::Store* mutable_store();
  void set_allocated_store(::metapb::Store* store);

  // @@protoc_insertion_point(class_scope:schedulerpb.PutStoreRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::RequestHeader* header_;
  ::metapb::Store* store_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class PutStoreResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.PutStoreResponse) */ {
 public:
  PutStoreResponse();
  virtual ~PutStoreResponse();

  PutStoreResponse(const PutStoreResponse& from);
  PutStoreResponse(PutStoreResponse&& from) noexcept
    : PutStoreResponse() {
    *this = ::std::move(from);
  }

  inline PutStoreResponse& operator=(const PutStoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutStoreResponse& operator=(PutStoreResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PutStoreResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutStoreResponse* internal_default_instance() {
    return reinterpret_cast<const PutStoreResponse*>(
               &_PutStoreResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(PutStoreResponse* other);
  friend void swap(PutStoreResponse& a, PutStoreResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutStoreResponse* New() const final {
    return CreateMaybeMessage<PutStoreResponse>(nullptr);
  }

  PutStoreResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PutStoreResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PutStoreResponse& from);
  void MergeFrom(const PutStoreResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutStoreResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.PutStoreResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:schedulerpb.PutStoreResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class GetAllStoresRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.GetAllStoresRequest) */ {
 public:
  GetAllStoresRequest();
  virtual ~GetAllStoresRequest();

  GetAllStoresRequest(const GetAllStoresRequest& from);
  GetAllStoresRequest(GetAllStoresRequest&& from) noexcept
    : GetAllStoresRequest() {
    *this = ::std::move(from);
  }

  inline GetAllStoresRequest& operator=(const GetAllStoresRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAllStoresRequest& operator=(GetAllStoresRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetAllStoresRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAllStoresRequest* internal_default_instance() {
    return reinterpret_cast<const GetAllStoresRequest*>(
               &_GetAllStoresRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(GetAllStoresRequest* other);
  friend void swap(GetAllStoresRequest& a, GetAllStoresRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAllStoresRequest* New() const final {
    return CreateMaybeMessage<GetAllStoresRequest>(nullptr);
  }

  GetAllStoresRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAllStoresRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetAllStoresRequest& from);
  void MergeFrom(const GetAllStoresRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAllStoresRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.GetAllStoresRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // bool exclude_tombstone_stores = 2;
  void clear_exclude_tombstone_stores();
  static const int kExcludeTombstoneStoresFieldNumber = 2;
  bool exclude_tombstone_stores() const;
  void set_exclude_tombstone_stores(bool value);

  // @@protoc_insertion_point(class_scope:schedulerpb.GetAllStoresRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::RequestHeader* header_;
  bool exclude_tombstone_stores_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class GetAllStoresResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.GetAllStoresResponse) */ {
 public:
  GetAllStoresResponse();
  virtual ~GetAllStoresResponse();

  GetAllStoresResponse(const GetAllStoresResponse& from);
  GetAllStoresResponse(GetAllStoresResponse&& from) noexcept
    : GetAllStoresResponse() {
    *this = ::std::move(from);
  }

  inline GetAllStoresResponse& operator=(const GetAllStoresResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAllStoresResponse& operator=(GetAllStoresResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetAllStoresResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAllStoresResponse* internal_default_instance() {
    return reinterpret_cast<const GetAllStoresResponse*>(
               &_GetAllStoresResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(GetAllStoresResponse* other);
  friend void swap(GetAllStoresResponse& a, GetAllStoresResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAllStoresResponse* New() const final {
    return CreateMaybeMessage<GetAllStoresResponse>(nullptr);
  }

  GetAllStoresResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAllStoresResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetAllStoresResponse& from);
  void MergeFrom(const GetAllStoresResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAllStoresResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.GetAllStoresResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metapb.Store stores = 2;
  int stores_size() const;
  void clear_stores();
  static const int kStoresFieldNumber = 2;
  ::metapb::Store* mutable_stores(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Store >*
      mutable_stores();
  const ::metapb::Store& stores(int index) const;
  ::metapb::Store* add_stores();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Store >&
      stores() const;

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:schedulerpb.GetAllStoresResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Store > stores_;
  ::schedulerpb::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class GetRegionRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.GetRegionRequest) */ {
 public:
  GetRegionRequest();
  virtual ~GetRegionRequest();

  GetRegionRequest(const GetRegionRequest& from);
  GetRegionRequest(GetRegionRequest&& from) noexcept
    : GetRegionRequest() {
    *this = ::std::move(from);
  }

  inline GetRegionRequest& operator=(const GetRegionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRegionRequest& operator=(GetRegionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetRegionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRegionRequest* internal_default_instance() {
    return reinterpret_cast<const GetRegionRequest*>(
               &_GetRegionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(GetRegionRequest* other);
  friend void swap(GetRegionRequest& a, GetRegionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRegionRequest* New() const final {
    return CreateMaybeMessage<GetRegionRequest>(nullptr);
  }

  GetRegionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRegionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetRegionRequest& from);
  void MergeFrom(const GetRegionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRegionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.GetRegionRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes region_key = 2;
  void clear_region_key();
  static const int kRegionKeyFieldNumber = 2;
  const std::string& region_key() const;
  void set_region_key(const std::string& value);
  void set_region_key(std::string&& value);
  void set_region_key(const char* value);
  void set_region_key(const void* value, size_t size);
  std::string* mutable_region_key();
  std::string* release_region_key();
  void set_allocated_region_key(std::string* region_key);

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:schedulerpb.GetRegionRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_key_;
  ::schedulerpb::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class GetRegionResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.GetRegionResponse) */ {
 public:
  GetRegionResponse();
  virtual ~GetRegionResponse();

  GetRegionResponse(const GetRegionResponse& from);
  GetRegionResponse(GetRegionResponse&& from) noexcept
    : GetRegionResponse() {
    *this = ::std::move(from);
  }

  inline GetRegionResponse& operator=(const GetRegionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRegionResponse& operator=(GetRegionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetRegionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRegionResponse* internal_default_instance() {
    return reinterpret_cast<const GetRegionResponse*>(
               &_GetRegionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(GetRegionResponse* other);
  friend void swap(GetRegionResponse& a, GetRegionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRegionResponse* New() const final {
    return CreateMaybeMessage<GetRegionResponse>(nullptr);
  }

  GetRegionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRegionResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetRegionResponse& from);
  void MergeFrom(const GetRegionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRegionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.GetRegionResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metapb.Peer slaves = 4;
  int slaves_size() const;
  void clear_slaves();
  static const int kSlavesFieldNumber = 4;
  ::metapb::Peer* mutable_slaves(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Peer >*
      mutable_slaves();
  const ::metapb::Peer& slaves(int index) const;
  ::metapb::Peer* add_slaves();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Peer >&
      slaves() const;

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // .metapb.Region region = 2;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 2;
  const ::metapb::Region& region() const;
  ::metapb::Region* release_region();
  ::metapb::Region* mutable_region();
  void set_allocated_region(::metapb::Region* region);

  // .metapb.Peer leader = 3;
  bool has_leader() const;
  void clear_leader();
  static const int kLeaderFieldNumber = 3;
  const ::metapb::Peer& leader() const;
  ::metapb::Peer* release_leader();
  ::metapb::Peer* mutable_leader();
  void set_allocated_leader(::metapb::Peer* leader);

  // @@protoc_insertion_point(class_scope:schedulerpb.GetRegionResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Peer > slaves_;
  ::schedulerpb::ResponseHeader* header_;
  ::metapb::Region* region_;
  ::metapb::Peer* leader_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class GetRegionByIDRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.GetRegionByIDRequest) */ {
 public:
  GetRegionByIDRequest();
  virtual ~GetRegionByIDRequest();

  GetRegionByIDRequest(const GetRegionByIDRequest& from);
  GetRegionByIDRequest(GetRegionByIDRequest&& from) noexcept
    : GetRegionByIDRequest() {
    *this = ::std::move(from);
  }

  inline GetRegionByIDRequest& operator=(const GetRegionByIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRegionByIDRequest& operator=(GetRegionByIDRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetRegionByIDRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRegionByIDRequest* internal_default_instance() {
    return reinterpret_cast<const GetRegionByIDRequest*>(
               &_GetRegionByIDRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(GetRegionByIDRequest* other);
  friend void swap(GetRegionByIDRequest& a, GetRegionByIDRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRegionByIDRequest* New() const final {
    return CreateMaybeMessage<GetRegionByIDRequest>(nullptr);
  }

  GetRegionByIDRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRegionByIDRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetRegionByIDRequest& from);
  void MergeFrom(const GetRegionByIDRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRegionByIDRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.GetRegionByIDRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // uint64 region_id = 2;
  void clear_region_id();
  static const int kRegionIdFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.GetRegionByIDRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::RequestHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::uint64 region_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class ScanRegionsRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.ScanRegionsRequest) */ {
 public:
  ScanRegionsRequest();
  virtual ~ScanRegionsRequest();

  ScanRegionsRequest(const ScanRegionsRequest& from);
  ScanRegionsRequest(ScanRegionsRequest&& from) noexcept
    : ScanRegionsRequest() {
    *this = ::std::move(from);
  }

  inline ScanRegionsRequest& operator=(const ScanRegionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScanRegionsRequest& operator=(ScanRegionsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScanRegionsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScanRegionsRequest* internal_default_instance() {
    return reinterpret_cast<const ScanRegionsRequest*>(
               &_ScanRegionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(ScanRegionsRequest* other);
  friend void swap(ScanRegionsRequest& a, ScanRegionsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScanRegionsRequest* New() const final {
    return CreateMaybeMessage<ScanRegionsRequest>(nullptr);
  }

  ScanRegionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScanRegionsRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScanRegionsRequest& from);
  void MergeFrom(const ScanRegionsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScanRegionsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.ScanRegionsRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes start_key = 2;
  void clear_start_key();
  static const int kStartKeyFieldNumber = 2;
  const std::string& start_key() const;
  void set_start_key(const std::string& value);
  void set_start_key(std::string&& value);
  void set_start_key(const char* value);
  void set_start_key(const void* value, size_t size);
  std::string* mutable_start_key();
  std::string* release_start_key();
  void set_allocated_start_key(std::string* start_key);

  // bytes end_key = 4;
  void clear_end_key();
  static const int kEndKeyFieldNumber = 4;
  const std::string& end_key() const;
  void set_end_key(const std::string& value);
  void set_end_key(std::string&& value);
  void set_end_key(const char* value);
  void set_end_key(const void* value, size_t size);
  std::string* mutable_end_key();
  std::string* release_end_key();
  void set_allocated_end_key(std::string* end_key);

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // int32 limit = 3;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 limit() const;
  void set_limit(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.ScanRegionsRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_key_;
  ::schedulerpb::RequestHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::int32 limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class ScanRegionsResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.ScanRegionsResponse) */ {
 public:
  ScanRegionsResponse();
  virtual ~ScanRegionsResponse();

  ScanRegionsResponse(const ScanRegionsResponse& from);
  ScanRegionsResponse(ScanRegionsResponse&& from) noexcept
    : ScanRegionsResponse() {
    *this = ::std::move(from);
  }

  inline ScanRegionsResponse& operator=(const ScanRegionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScanRegionsResponse& operator=(ScanRegionsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScanRegionsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScanRegionsResponse* internal_default_instance() {
    return reinterpret_cast<const ScanRegionsResponse*>(
               &_ScanRegionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(ScanRegionsResponse* other);
  friend void swap(ScanRegionsResponse& a, ScanRegionsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScanRegionsResponse* New() const final {
    return CreateMaybeMessage<ScanRegionsResponse>(nullptr);
  }

  ScanRegionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScanRegionsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScanRegionsResponse& from);
  void MergeFrom(const ScanRegionsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScanRegionsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.ScanRegionsResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metapb.Region regions = 2;
  int regions_size() const;
  void clear_regions();
  static const int kRegionsFieldNumber = 2;
  ::metapb::Region* mutable_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Region >*
      mutable_regions();
  const ::metapb::Region& regions(int index) const;
  ::metapb::Region* add_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Region >&
      regions() const;

  // repeated .metapb.Peer leaders = 3;
  int leaders_size() const;
  void clear_leaders();
  static const int kLeadersFieldNumber = 3;
  ::metapb::Peer* mutable_leaders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Peer >*
      mutable_leaders();
  const ::metapb::Peer& leaders(int index) const;
  ::metapb::Peer* add_leaders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Peer >&
      leaders() const;

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:schedulerpb.ScanRegionsResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Region > regions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Peer > leaders_;
  ::schedulerpb::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class GetClusterConfigRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.GetClusterConfigRequest) */ {
 public:
  GetClusterConfigRequest();
  virtual ~GetClusterConfigRequest();

  GetClusterConfigRequest(const GetClusterConfigRequest& from);
  GetClusterConfigRequest(GetClusterConfigRequest&& from) noexcept
    : GetClusterConfigRequest() {
    *this = ::std::move(from);
  }

  inline GetClusterConfigRequest& operator=(const GetClusterConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetClusterConfigRequest& operator=(GetClusterConfigRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetClusterConfigRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetClusterConfigRequest* internal_default_instance() {
    return reinterpret_cast<const GetClusterConfigRequest*>(
               &_GetClusterConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(GetClusterConfigRequest* other);
  friend void swap(GetClusterConfigRequest& a, GetClusterConfigRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetClusterConfigRequest* New() const final {
    return CreateMaybeMessage<GetClusterConfigRequest>(nullptr);
  }

  GetClusterConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetClusterConfigRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetClusterConfigRequest& from);
  void MergeFrom(const GetClusterConfigRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetClusterConfigRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.GetClusterConfigRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:schedulerpb.GetClusterConfigRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class GetClusterConfigResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.GetClusterConfigResponse) */ {
 public:
  GetClusterConfigResponse();
  virtual ~GetClusterConfigResponse();

  GetClusterConfigResponse(const GetClusterConfigResponse& from);
  GetClusterConfigResponse(GetClusterConfigResponse&& from) noexcept
    : GetClusterConfigResponse() {
    *this = ::std::move(from);
  }

  inline GetClusterConfigResponse& operator=(const GetClusterConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetClusterConfigResponse& operator=(GetClusterConfigResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetClusterConfigResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetClusterConfigResponse* internal_default_instance() {
    return reinterpret_cast<const GetClusterConfigResponse*>(
               &_GetClusterConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(GetClusterConfigResponse* other);
  friend void swap(GetClusterConfigResponse& a, GetClusterConfigResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetClusterConfigResponse* New() const final {
    return CreateMaybeMessage<GetClusterConfigResponse>(nullptr);
  }

  GetClusterConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetClusterConfigResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetClusterConfigResponse& from);
  void MergeFrom(const GetClusterConfigResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetClusterConfigResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.GetClusterConfigResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // .metapb.Cluster cluster = 2;
  bool has_cluster() const;
  void clear_cluster();
  static const int kClusterFieldNumber = 2;
  const ::metapb::Cluster& cluster() const;
  ::metapb::Cluster* release_cluster();
  ::metapb::Cluster* mutable_cluster();
  void set_allocated_cluster(::metapb::Cluster* cluster);

  // @@protoc_insertion_point(class_scope:schedulerpb.GetClusterConfigResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::ResponseHeader* header_;
  ::metapb::Cluster* cluster_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class PutClusterConfigRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.PutClusterConfigRequest) */ {
 public:
  PutClusterConfigRequest();
  virtual ~PutClusterConfigRequest();

  PutClusterConfigRequest(const PutClusterConfigRequest& from);
  PutClusterConfigRequest(PutClusterConfigRequest&& from) noexcept
    : PutClusterConfigRequest() {
    *this = ::std::move(from);
  }

  inline PutClusterConfigRequest& operator=(const PutClusterConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutClusterConfigRequest& operator=(PutClusterConfigRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PutClusterConfigRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutClusterConfigRequest* internal_default_instance() {
    return reinterpret_cast<const PutClusterConfigRequest*>(
               &_PutClusterConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(PutClusterConfigRequest* other);
  friend void swap(PutClusterConfigRequest& a, PutClusterConfigRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutClusterConfigRequest* New() const final {
    return CreateMaybeMessage<PutClusterConfigRequest>(nullptr);
  }

  PutClusterConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PutClusterConfigRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PutClusterConfigRequest& from);
  void MergeFrom(const PutClusterConfigRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutClusterConfigRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.PutClusterConfigRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // .metapb.Cluster cluster = 2;
  bool has_cluster() const;
  void clear_cluster();
  static const int kClusterFieldNumber = 2;
  const ::metapb::Cluster& cluster() const;
  ::metapb::Cluster* release_cluster();
  ::metapb::Cluster* mutable_cluster();
  void set_allocated_cluster(::metapb::Cluster* cluster);

  // @@protoc_insertion_point(class_scope:schedulerpb.PutClusterConfigRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::RequestHeader* header_;
  ::metapb::Cluster* cluster_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class PutClusterConfigResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.PutClusterConfigResponse) */ {
 public:
  PutClusterConfigResponse();
  virtual ~PutClusterConfigResponse();

  PutClusterConfigResponse(const PutClusterConfigResponse& from);
  PutClusterConfigResponse(PutClusterConfigResponse&& from) noexcept
    : PutClusterConfigResponse() {
    *this = ::std::move(from);
  }

  inline PutClusterConfigResponse& operator=(const PutClusterConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutClusterConfigResponse& operator=(PutClusterConfigResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PutClusterConfigResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PutClusterConfigResponse* internal_default_instance() {
    return reinterpret_cast<const PutClusterConfigResponse*>(
               &_PutClusterConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(PutClusterConfigResponse* other);
  friend void swap(PutClusterConfigResponse& a, PutClusterConfigResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PutClusterConfigResponse* New() const final {
    return CreateMaybeMessage<PutClusterConfigResponse>(nullptr);
  }

  PutClusterConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PutClusterConfigResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PutClusterConfigResponse& from);
  void MergeFrom(const PutClusterConfigResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutClusterConfigResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.PutClusterConfigResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:schedulerpb.PutClusterConfigResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class Member :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.Member) */ {
 public:
  Member();
  virtual ~Member();

  Member(const Member& from);
  Member(Member&& from) noexcept
    : Member() {
    *this = ::std::move(from);
  }

  inline Member& operator=(const Member& from) {
    CopyFrom(from);
    return *this;
  }
  inline Member& operator=(Member&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Member& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Member* internal_default_instance() {
    return reinterpret_cast<const Member*>(
               &_Member_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(Member* other);
  friend void swap(Member& a, Member& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Member* New() const final {
    return CreateMaybeMessage<Member>(nullptr);
  }

  Member* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Member>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Member& from);
  void MergeFrom(const Member& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Member* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.Member";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string peer_urls = 3;
  int peer_urls_size() const;
  void clear_peer_urls();
  static const int kPeerUrlsFieldNumber = 3;
  const std::string& peer_urls(int index) const;
  std::string* mutable_peer_urls(int index);
  void set_peer_urls(int index, const std::string& value);
  void set_peer_urls(int index, std::string&& value);
  void set_peer_urls(int index, const char* value);
  void set_peer_urls(int index, const char* value, size_t size);
  std::string* add_peer_urls();
  void add_peer_urls(const std::string& value);
  void add_peer_urls(std::string&& value);
  void add_peer_urls(const char* value);
  void add_peer_urls(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& peer_urls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_peer_urls();

  // repeated string client_urls = 4;
  int client_urls_size() const;
  void clear_client_urls();
  static const int kClientUrlsFieldNumber = 4;
  const std::string& client_urls(int index) const;
  std::string* mutable_client_urls(int index);
  void set_client_urls(int index, const std::string& value);
  void set_client_urls(int index, std::string&& value);
  void set_client_urls(int index, const char* value);
  void set_client_urls(int index, const char* value, size_t size);
  std::string* add_client_urls();
  void add_client_urls(const std::string& value);
  void add_client_urls(std::string&& value);
  void add_client_urls(const char* value);
  void add_client_urls(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& client_urls() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_client_urls();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // uint64 member_id = 2;
  void clear_member_id();
  static const int kMemberIdFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint64 member_id() const;
  void set_member_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // int32 leader_priority = 5;
  void clear_leader_priority();
  static const int kLeaderPriorityFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::int32 leader_priority() const;
  void set_leader_priority(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.Member)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> peer_urls_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> client_urls_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 member_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 leader_priority_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class GetMembersRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.GetMembersRequest) */ {
 public:
  GetMembersRequest();
  virtual ~GetMembersRequest();

  GetMembersRequest(const GetMembersRequest& from);
  GetMembersRequest(GetMembersRequest&& from) noexcept
    : GetMembersRequest() {
    *this = ::std::move(from);
  }

  inline GetMembersRequest& operator=(const GetMembersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMembersRequest& operator=(GetMembersRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetMembersRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetMembersRequest* internal_default_instance() {
    return reinterpret_cast<const GetMembersRequest*>(
               &_GetMembersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(GetMembersRequest* other);
  friend void swap(GetMembersRequest& a, GetMembersRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetMembersRequest* New() const final {
    return CreateMaybeMessage<GetMembersRequest>(nullptr);
  }

  GetMembersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetMembersRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetMembersRequest& from);
  void MergeFrom(const GetMembersRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMembersRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.GetMembersRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:schedulerpb.GetMembersRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class GetMembersResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.GetMembersResponse) */ {
 public:
  GetMembersResponse();
  virtual ~GetMembersResponse();

  GetMembersResponse(const GetMembersResponse& from);
  GetMembersResponse(GetMembersResponse&& from) noexcept
    : GetMembersResponse() {
    *this = ::std::move(from);
  }

  inline GetMembersResponse& operator=(const GetMembersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMembersResponse& operator=(GetMembersResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetMembersResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetMembersResponse* internal_default_instance() {
    return reinterpret_cast<const GetMembersResponse*>(
               &_GetMembersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(GetMembersResponse* other);
  friend void swap(GetMembersResponse& a, GetMembersResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetMembersResponse* New() const final {
    return CreateMaybeMessage<GetMembersResponse>(nullptr);
  }

  GetMembersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetMembersResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetMembersResponse& from);
  void MergeFrom(const GetMembersResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMembersResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.GetMembersResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .schedulerpb.Member members = 2;
  int members_size() const;
  void clear_members();
  static const int kMembersFieldNumber = 2;
  ::schedulerpb::Member* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::Member >*
      mutable_members();
  const ::schedulerpb::Member& members(int index) const;
  ::schedulerpb::Member* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::Member >&
      members() const;

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // .schedulerpb.Member leader = 3;
  bool has_leader() const;
  void clear_leader();
  static const int kLeaderFieldNumber = 3;
  const ::schedulerpb::Member& leader() const;
  ::schedulerpb::Member* release_leader();
  ::schedulerpb::Member* mutable_leader();
  void set_allocated_leader(::schedulerpb::Member* leader);

  // .schedulerpb.Member etcd_leader = 4;
  bool has_etcd_leader() const;
  void clear_etcd_leader();
  static const int kEtcdLeaderFieldNumber = 4;
  const ::schedulerpb::Member& etcd_leader() const;
  ::schedulerpb::Member* release_etcd_leader();
  ::schedulerpb::Member* mutable_etcd_leader();
  void set_allocated_etcd_leader(::schedulerpb::Member* etcd_leader);

  // @@protoc_insertion_point(class_scope:schedulerpb.GetMembersResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::Member > members_;
  ::schedulerpb::ResponseHeader* header_;
  ::schedulerpb::Member* leader_;
  ::schedulerpb::Member* etcd_leader_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class RegionHeartbeatRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.RegionHeartbeatRequest) */ {
 public:
  RegionHeartbeatRequest();
  virtual ~RegionHeartbeatRequest();

  RegionHeartbeatRequest(const RegionHeartbeatRequest& from);
  RegionHeartbeatRequest(RegionHeartbeatRequest&& from) noexcept
    : RegionHeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline RegionHeartbeatRequest& operator=(const RegionHeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionHeartbeatRequest& operator=(RegionHeartbeatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegionHeartbeatRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionHeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const RegionHeartbeatRequest*>(
               &_RegionHeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(RegionHeartbeatRequest* other);
  friend void swap(RegionHeartbeatRequest& a, RegionHeartbeatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegionHeartbeatRequest* New() const final {
    return CreateMaybeMessage<RegionHeartbeatRequest>(nullptr);
  }

  RegionHeartbeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionHeartbeatRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegionHeartbeatRequest& from);
  void MergeFrom(const RegionHeartbeatRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionHeartbeatRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.RegionHeartbeatRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metapb.Peer pending_peers = 5;
  int pending_peers_size() const;
  void clear_pending_peers();
  static const int kPendingPeersFieldNumber = 5;
  ::metapb::Peer* mutable_pending_peers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Peer >*
      mutable_pending_peers();
  const ::metapb::Peer& pending_peers(int index) const;
  ::metapb::Peer* add_pending_peers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Peer >&
      pending_peers() const;

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // .metapb.Region region = 2;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 2;
  const ::metapb::Region& region() const;
  ::metapb::Region* release_region();
  ::metapb::Region* mutable_region();
  void set_allocated_region(::metapb::Region* region);

  // .metapb.Peer leader = 3;
  bool has_leader() const;
  void clear_leader();
  static const int kLeaderFieldNumber = 3;
  const ::metapb::Peer& leader() const;
  ::metapb::Peer* release_leader();
  ::metapb::Peer* mutable_leader();
  void set_allocated_leader(::metapb::Peer* leader);

  // uint64 approximate_size = 10;
  void clear_approximate_size();
  static const int kApproximateSizeFieldNumber = 10;
  ::PROTOBUF_NAMESPACE_ID::uint64 approximate_size() const;
  void set_approximate_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.RegionHeartbeatRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Peer > pending_peers_;
  ::schedulerpb::RequestHeader* header_;
  ::metapb::Region* region_;
  ::metapb::Peer* leader_;
  ::PROTOBUF_NAMESPACE_ID::uint64 approximate_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class ChangePeer :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.ChangePeer) */ {
 public:
  ChangePeer();
  virtual ~ChangePeer();

  ChangePeer(const ChangePeer& from);
  ChangePeer(ChangePeer&& from) noexcept
    : ChangePeer() {
    *this = ::std::move(from);
  }

  inline ChangePeer& operator=(const ChangePeer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangePeer& operator=(ChangePeer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChangePeer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangePeer* internal_default_instance() {
    return reinterpret_cast<const ChangePeer*>(
               &_ChangePeer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(ChangePeer* other);
  friend void swap(ChangePeer& a, ChangePeer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChangePeer* New() const final {
    return CreateMaybeMessage<ChangePeer>(nullptr);
  }

  ChangePeer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChangePeer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChangePeer& from);
  void MergeFrom(const ChangePeer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangePeer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.ChangePeer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metapb.Peer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::metapb::Peer& peer() const;
  ::metapb::Peer* release_peer();
  ::metapb::Peer* mutable_peer();
  void set_allocated_peer(::metapb::Peer* peer);

  // .eraftpb.ConfChangeType change_type = 2;
  void clear_change_type();
  static const int kChangeTypeFieldNumber = 2;
  ::eraftpb::ConfChangeType change_type() const;
  void set_change_type(::eraftpb::ConfChangeType value);

  // @@protoc_insertion_point(class_scope:schedulerpb.ChangePeer)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::metapb::Peer* peer_;
  int change_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class TransferLeader :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.TransferLeader) */ {
 public:
  TransferLeader();
  virtual ~TransferLeader();

  TransferLeader(const TransferLeader& from);
  TransferLeader(TransferLeader&& from) noexcept
    : TransferLeader() {
    *this = ::std::move(from);
  }

  inline TransferLeader& operator=(const TransferLeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferLeader& operator=(TransferLeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransferLeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferLeader* internal_default_instance() {
    return reinterpret_cast<const TransferLeader*>(
               &_TransferLeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(TransferLeader* other);
  friend void swap(TransferLeader& a, TransferLeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferLeader* New() const final {
    return CreateMaybeMessage<TransferLeader>(nullptr);
  }

  TransferLeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransferLeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransferLeader& from);
  void MergeFrom(const TransferLeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferLeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.TransferLeader";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metapb.Peer peer = 1;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 1;
  const ::metapb::Peer& peer() const;
  ::metapb::Peer* release_peer();
  ::metapb::Peer* mutable_peer();
  void set_allocated_peer(::metapb::Peer* peer);

  // @@protoc_insertion_point(class_scope:schedulerpb.TransferLeader)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::metapb::Peer* peer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class RegionHeartbeatResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.RegionHeartbeatResponse) */ {
 public:
  RegionHeartbeatResponse();
  virtual ~RegionHeartbeatResponse();

  RegionHeartbeatResponse(const RegionHeartbeatResponse& from);
  RegionHeartbeatResponse(RegionHeartbeatResponse&& from) noexcept
    : RegionHeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline RegionHeartbeatResponse& operator=(const RegionHeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionHeartbeatResponse& operator=(RegionHeartbeatResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegionHeartbeatResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionHeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const RegionHeartbeatResponse*>(
               &_RegionHeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(RegionHeartbeatResponse* other);
  friend void swap(RegionHeartbeatResponse& a, RegionHeartbeatResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegionHeartbeatResponse* New() const final {
    return CreateMaybeMessage<RegionHeartbeatResponse>(nullptr);
  }

  RegionHeartbeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionHeartbeatResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegionHeartbeatResponse& from);
  void MergeFrom(const RegionHeartbeatResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionHeartbeatResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.RegionHeartbeatResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // .schedulerpb.ChangePeer change_peer = 2;
  bool has_change_peer() const;
  void clear_change_peer();
  static const int kChangePeerFieldNumber = 2;
  const ::schedulerpb::ChangePeer& change_peer() const;
  ::schedulerpb::ChangePeer* release_change_peer();
  ::schedulerpb::ChangePeer* mutable_change_peer();
  void set_allocated_change_peer(::schedulerpb::ChangePeer* change_peer);

  // .schedulerpb.TransferLeader transfer_leader = 3;
  bool has_transfer_leader() const;
  void clear_transfer_leader();
  static const int kTransferLeaderFieldNumber = 3;
  const ::schedulerpb::TransferLeader& transfer_leader() const;
  ::schedulerpb::TransferLeader* release_transfer_leader();
  ::schedulerpb::TransferLeader* mutable_transfer_leader();
  void set_allocated_transfer_leader(::schedulerpb::TransferLeader* transfer_leader);

  // .metapb.RegionEpoch region_epoch = 5;
  bool has_region_epoch() const;
  void clear_region_epoch();
  static const int kRegionEpochFieldNumber = 5;
  const ::metapb::RegionEpoch& region_epoch() const;
  ::metapb::RegionEpoch* release_region_epoch();
  ::metapb::RegionEpoch* mutable_region_epoch();
  void set_allocated_region_epoch(::metapb::RegionEpoch* region_epoch);

  // .metapb.Peer target_peer = 6;
  bool has_target_peer() const;
  void clear_target_peer();
  static const int kTargetPeerFieldNumber = 6;
  const ::metapb::Peer& target_peer() const;
  ::metapb::Peer* release_target_peer();
  ::metapb::Peer* mutable_target_peer();
  void set_allocated_target_peer(::metapb::Peer* target_peer);

  // uint64 region_id = 4;
  void clear_region_id();
  static const int kRegionIdFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.RegionHeartbeatResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::ResponseHeader* header_;
  ::schedulerpb::ChangePeer* change_peer_;
  ::schedulerpb::TransferLeader* transfer_leader_;
  ::metapb::RegionEpoch* region_epoch_;
  ::metapb::Peer* target_peer_;
  ::PROTOBUF_NAMESPACE_ID::uint64 region_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class AskSplitRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.AskSplitRequest) */ {
 public:
  AskSplitRequest();
  virtual ~AskSplitRequest();

  AskSplitRequest(const AskSplitRequest& from);
  AskSplitRequest(AskSplitRequest&& from) noexcept
    : AskSplitRequest() {
    *this = ::std::move(from);
  }

  inline AskSplitRequest& operator=(const AskSplitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskSplitRequest& operator=(AskSplitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AskSplitRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AskSplitRequest* internal_default_instance() {
    return reinterpret_cast<const AskSplitRequest*>(
               &_AskSplitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(AskSplitRequest* other);
  friend void swap(AskSplitRequest& a, AskSplitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AskSplitRequest* New() const final {
    return CreateMaybeMessage<AskSplitRequest>(nullptr);
  }

  AskSplitRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AskSplitRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AskSplitRequest& from);
  void MergeFrom(const AskSplitRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AskSplitRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.AskSplitRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // .metapb.Region region = 2;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 2;
  const ::metapb::Region& region() const;
  ::metapb::Region* release_region();
  ::metapb::Region* mutable_region();
  void set_allocated_region(::metapb::Region* region);

  // @@protoc_insertion_point(class_scope:schedulerpb.AskSplitRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::RequestHeader* header_;
  ::metapb::Region* region_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class AskSplitResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.AskSplitResponse) */ {
 public:
  AskSplitResponse();
  virtual ~AskSplitResponse();

  AskSplitResponse(const AskSplitResponse& from);
  AskSplitResponse(AskSplitResponse&& from) noexcept
    : AskSplitResponse() {
    *this = ::std::move(from);
  }

  inline AskSplitResponse& operator=(const AskSplitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskSplitResponse& operator=(AskSplitResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AskSplitResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AskSplitResponse* internal_default_instance() {
    return reinterpret_cast<const AskSplitResponse*>(
               &_AskSplitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(AskSplitResponse* other);
  friend void swap(AskSplitResponse& a, AskSplitResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AskSplitResponse* New() const final {
    return CreateMaybeMessage<AskSplitResponse>(nullptr);
  }

  AskSplitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AskSplitResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AskSplitResponse& from);
  void MergeFrom(const AskSplitResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AskSplitResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.AskSplitResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 new_peer_ids = 3;
  int new_peer_ids_size() const;
  void clear_new_peer_ids();
  static const int kNewPeerIdsFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint64 new_peer_ids(int index) const;
  void set_new_peer_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_new_peer_ids(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      new_peer_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_new_peer_ids();

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // uint64 new_region_id = 2;
  void clear_new_region_id();
  static const int kNewRegionIdFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint64 new_region_id() const;
  void set_new_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.AskSplitResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > new_peer_ids_;
  mutable std::atomic<int> _new_peer_ids_cached_byte_size_;
  ::schedulerpb::ResponseHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::uint64 new_region_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class ReportSplitRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.ReportSplitRequest) */ {
 public:
  ReportSplitRequest();
  virtual ~ReportSplitRequest();

  ReportSplitRequest(const ReportSplitRequest& from);
  ReportSplitRequest(ReportSplitRequest&& from) noexcept
    : ReportSplitRequest() {
    *this = ::std::move(from);
  }

  inline ReportSplitRequest& operator=(const ReportSplitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportSplitRequest& operator=(ReportSplitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReportSplitRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportSplitRequest* internal_default_instance() {
    return reinterpret_cast<const ReportSplitRequest*>(
               &_ReportSplitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(ReportSplitRequest* other);
  friend void swap(ReportSplitRequest& a, ReportSplitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportSplitRequest* New() const final {
    return CreateMaybeMessage<ReportSplitRequest>(nullptr);
  }

  ReportSplitRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReportSplitRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReportSplitRequest& from);
  void MergeFrom(const ReportSplitRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportSplitRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.ReportSplitRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // .metapb.Region left = 2;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 2;
  const ::metapb::Region& left() const;
  ::metapb::Region* release_left();
  ::metapb::Region* mutable_left();
  void set_allocated_left(::metapb::Region* left);

  // .metapb.Region right = 3;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 3;
  const ::metapb::Region& right() const;
  ::metapb::Region* release_right();
  ::metapb::Region* mutable_right();
  void set_allocated_right(::metapb::Region* right);

  // @@protoc_insertion_point(class_scope:schedulerpb.ReportSplitRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::RequestHeader* header_;
  ::metapb::Region* left_;
  ::metapb::Region* right_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class ReportSplitResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.ReportSplitResponse) */ {
 public:
  ReportSplitResponse();
  virtual ~ReportSplitResponse();

  ReportSplitResponse(const ReportSplitResponse& from);
  ReportSplitResponse(ReportSplitResponse&& from) noexcept
    : ReportSplitResponse() {
    *this = ::std::move(from);
  }

  inline ReportSplitResponse& operator=(const ReportSplitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportSplitResponse& operator=(ReportSplitResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReportSplitResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportSplitResponse* internal_default_instance() {
    return reinterpret_cast<const ReportSplitResponse*>(
               &_ReportSplitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(ReportSplitResponse* other);
  friend void swap(ReportSplitResponse& a, ReportSplitResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportSplitResponse* New() const final {
    return CreateMaybeMessage<ReportSplitResponse>(nullptr);
  }

  ReportSplitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReportSplitResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReportSplitResponse& from);
  void MergeFrom(const ReportSplitResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportSplitResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.ReportSplitResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:schedulerpb.ReportSplitResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class SplitID :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.SplitID) */ {
 public:
  SplitID();
  virtual ~SplitID();

  SplitID(const SplitID& from);
  SplitID(SplitID&& from) noexcept
    : SplitID() {
    *this = ::std::move(from);
  }

  inline SplitID& operator=(const SplitID& from) {
    CopyFrom(from);
    return *this;
  }
  inline SplitID& operator=(SplitID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SplitID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SplitID* internal_default_instance() {
    return reinterpret_cast<const SplitID*>(
               &_SplitID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(SplitID* other);
  friend void swap(SplitID& a, SplitID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SplitID* New() const final {
    return CreateMaybeMessage<SplitID>(nullptr);
  }

  SplitID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SplitID>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SplitID& from);
  void MergeFrom(const SplitID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SplitID* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.SplitID";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 new_peer_ids = 2;
  int new_peer_ids_size() const;
  void clear_new_peer_ids();
  static const int kNewPeerIdsFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint64 new_peer_ids(int index) const;
  void set_new_peer_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_new_peer_ids(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      new_peer_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_new_peer_ids();

  // uint64 new_region_id = 1;
  void clear_new_region_id();
  static const int kNewRegionIdFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint64 new_region_id() const;
  void set_new_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.SplitID)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > new_peer_ids_;
  mutable std::atomic<int> _new_peer_ids_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 new_region_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class TimeInterval :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.TimeInterval) */ {
 public:
  TimeInterval();
  virtual ~TimeInterval();

  TimeInterval(const TimeInterval& from);
  TimeInterval(TimeInterval&& from) noexcept
    : TimeInterval() {
    *this = ::std::move(from);
  }

  inline TimeInterval& operator=(const TimeInterval& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeInterval& operator=(TimeInterval&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TimeInterval& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeInterval* internal_default_instance() {
    return reinterpret_cast<const TimeInterval*>(
               &_TimeInterval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(TimeInterval* other);
  friend void swap(TimeInterval& a, TimeInterval& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeInterval* New() const final {
    return CreateMaybeMessage<TimeInterval>(nullptr);
  }

  TimeInterval* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TimeInterval>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TimeInterval& from);
  void MergeFrom(const TimeInterval& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeInterval* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.TimeInterval";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 start_timestamp = 1;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint64 start_timestamp() const;
  void set_start_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 end_timestamp = 2;
  void clear_end_timestamp();
  static const int kEndTimestampFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint64 end_timestamp() const;
  void set_end_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.TimeInterval)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 start_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 end_timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class RecordPair :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.RecordPair) */ {
 public:
  RecordPair();
  virtual ~RecordPair();

  RecordPair(const RecordPair& from);
  RecordPair(RecordPair&& from) noexcept
    : RecordPair() {
    *this = ::std::move(from);
  }

  inline RecordPair& operator=(const RecordPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordPair& operator=(RecordPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RecordPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecordPair* internal_default_instance() {
    return reinterpret_cast<const RecordPair*>(
               &_RecordPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(RecordPair* other);
  friend void swap(RecordPair& a, RecordPair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecordPair* New() const final {
    return CreateMaybeMessage<RecordPair>(nullptr);
  }

  RecordPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecordPair>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecordPair& from);
  void MergeFrom(const RecordPair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordPair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.RecordPair";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);

  // uint64 value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.RecordPair)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class StoreStats :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.StoreStats) */ {
 public:
  StoreStats();
  virtual ~StoreStats();

  StoreStats(const StoreStats& from);
  StoreStats(StoreStats&& from) noexcept
    : StoreStats() {
    *this = ::std::move(from);
  }

  inline StoreStats& operator=(const StoreStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreStats& operator=(StoreStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StoreStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StoreStats* internal_default_instance() {
    return reinterpret_cast<const StoreStats*>(
               &_StoreStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(StoreStats* other);
  friend void swap(StoreStats& a, StoreStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StoreStats* New() const final {
    return CreateMaybeMessage<StoreStats>(nullptr);
  }

  StoreStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StoreStats>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StoreStats& from);
  void MergeFrom(const StoreStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.StoreStats";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .schedulerpb.RecordPair cpu_usages = 16;
  int cpu_usages_size() const;
  void clear_cpu_usages();
  static const int kCpuUsagesFieldNumber = 16;
  ::schedulerpb::RecordPair* mutable_cpu_usages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair >*
      mutable_cpu_usages();
  const ::schedulerpb::RecordPair& cpu_usages(int index) const;
  ::schedulerpb::RecordPair* add_cpu_usages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair >&
      cpu_usages() const;

  // repeated .schedulerpb.RecordPair read_io_rates = 17;
  int read_io_rates_size() const;
  void clear_read_io_rates();
  static const int kReadIoRatesFieldNumber = 17;
  ::schedulerpb::RecordPair* mutable_read_io_rates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair >*
      mutable_read_io_rates();
  const ::schedulerpb::RecordPair& read_io_rates(int index) const;
  ::schedulerpb::RecordPair* add_read_io_rates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair >&
      read_io_rates() const;

  // repeated .schedulerpb.RecordPair write_io_rates = 18;
  int write_io_rates_size() const;
  void clear_write_io_rates();
  static const int kWriteIoRatesFieldNumber = 18;
  ::schedulerpb::RecordPair* mutable_write_io_rates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair >*
      mutable_write_io_rates();
  const ::schedulerpb::RecordPair& write_io_rates(int index) const;
  ::schedulerpb::RecordPair* add_write_io_rates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair >&
      write_io_rates() const;

  // repeated .schedulerpb.RecordPair op_latencies = 19;
  int op_latencies_size() const;
  void clear_op_latencies();
  static const int kOpLatenciesFieldNumber = 19;
  ::schedulerpb::RecordPair* mutable_op_latencies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair >*
      mutable_op_latencies();
  const ::schedulerpb::RecordPair& op_latencies(int index) const;
  ::schedulerpb::RecordPair* add_op_latencies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair >&
      op_latencies() const;

  // .schedulerpb.TimeInterval interval = 15;
  bool has_interval() const;
  void clear_interval();
  static const int kIntervalFieldNumber = 15;
  const ::schedulerpb::TimeInterval& interval() const;
  ::schedulerpb::TimeInterval* release_interval();
  ::schedulerpb::TimeInterval* mutable_interval();
  void set_allocated_interval(::schedulerpb::TimeInterval* interval);

  // uint64 store_id = 1;
  void clear_store_id();
  static const int kStoreIdFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint64 store_id() const;
  void set_store_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 capacity = 2;
  void clear_capacity();
  static const int kCapacityFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint64 capacity() const;
  void set_capacity(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 available = 3;
  void clear_available();
  static const int kAvailableFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint64 available() const;
  void set_available(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint32 region_count = 4;
  void clear_region_count();
  static const int kRegionCountFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint32 region_count() const;
  void set_region_count(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 sending_snap_count = 5;
  void clear_sending_snap_count();
  static const int kSendingSnapCountFieldNumber = 5;
  ::PROTOBUF_NAMESPACE_ID::uint32 sending_snap_count() const;
  void set_sending_snap_count(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 receiving_snap_count = 6;
  void clear_receiving_snap_count();
  static const int kReceivingSnapCountFieldNumber = 6;
  ::PROTOBUF_NAMESPACE_ID::uint32 receiving_snap_count() const;
  void set_receiving_snap_count(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 start_time = 7;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::uint32 start_time() const;
  void set_start_time(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 applying_snap_count = 8;
  void clear_applying_snap_count();
  static const int kApplyingSnapCountFieldNumber = 8;
  ::PROTOBUF_NAMESPACE_ID::uint32 applying_snap_count() const;
  void set_applying_snap_count(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // bool is_busy = 9;
  void clear_is_busy();
  static const int kIsBusyFieldNumber = 9;
  bool is_busy() const;
  void set_is_busy(bool value);

  // uint64 used_size = 10;
  void clear_used_size();
  static const int kUsedSizeFieldNumber = 10;
  ::PROTOBUF_NAMESPACE_ID::uint64 used_size() const;
  void set_used_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.StoreStats)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair > cpu_usages_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair > read_io_rates_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair > write_io_rates_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair > op_latencies_;
  ::schedulerpb::TimeInterval* interval_;
  ::PROTOBUF_NAMESPACE_ID::uint64 store_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 capacity_;
  ::PROTOBUF_NAMESPACE_ID::uint64 available_;
  ::PROTOBUF_NAMESPACE_ID::uint32 region_count_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sending_snap_count_;
  ::PROTOBUF_NAMESPACE_ID::uint32 receiving_snap_count_;
  ::PROTOBUF_NAMESPACE_ID::uint32 start_time_;
  ::PROTOBUF_NAMESPACE_ID::uint32 applying_snap_count_;
  bool is_busy_;
  ::PROTOBUF_NAMESPACE_ID::uint64 used_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class StoreHeartbeatRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.StoreHeartbeatRequest) */ {
 public:
  StoreHeartbeatRequest();
  virtual ~StoreHeartbeatRequest();

  StoreHeartbeatRequest(const StoreHeartbeatRequest& from);
  StoreHeartbeatRequest(StoreHeartbeatRequest&& from) noexcept
    : StoreHeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline StoreHeartbeatRequest& operator=(const StoreHeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreHeartbeatRequest& operator=(StoreHeartbeatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StoreHeartbeatRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StoreHeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const StoreHeartbeatRequest*>(
               &_StoreHeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(StoreHeartbeatRequest* other);
  friend void swap(StoreHeartbeatRequest& a, StoreHeartbeatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StoreHeartbeatRequest* New() const final {
    return CreateMaybeMessage<StoreHeartbeatRequest>(nullptr);
  }

  StoreHeartbeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StoreHeartbeatRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StoreHeartbeatRequest& from);
  void MergeFrom(const StoreHeartbeatRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreHeartbeatRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.StoreHeartbeatRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // .schedulerpb.StoreStats stats = 2;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 2;
  const ::schedulerpb::StoreStats& stats() const;
  ::schedulerpb::StoreStats* release_stats();
  ::schedulerpb::StoreStats* mutable_stats();
  void set_allocated_stats(::schedulerpb::StoreStats* stats);

  // @@protoc_insertion_point(class_scope:schedulerpb.StoreHeartbeatRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::RequestHeader* header_;
  ::schedulerpb::StoreStats* stats_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class StoreHeartbeatResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.StoreHeartbeatResponse) */ {
 public:
  StoreHeartbeatResponse();
  virtual ~StoreHeartbeatResponse();

  StoreHeartbeatResponse(const StoreHeartbeatResponse& from);
  StoreHeartbeatResponse(StoreHeartbeatResponse&& from) noexcept
    : StoreHeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline StoreHeartbeatResponse& operator=(const StoreHeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreHeartbeatResponse& operator=(StoreHeartbeatResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StoreHeartbeatResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StoreHeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const StoreHeartbeatResponse*>(
               &_StoreHeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(StoreHeartbeatResponse* other);
  friend void swap(StoreHeartbeatResponse& a, StoreHeartbeatResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StoreHeartbeatResponse* New() const final {
    return CreateMaybeMessage<StoreHeartbeatResponse>(nullptr);
  }

  StoreHeartbeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StoreHeartbeatResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StoreHeartbeatResponse& from);
  void MergeFrom(const StoreHeartbeatResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreHeartbeatResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.StoreHeartbeatResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:schedulerpb.StoreHeartbeatResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class ScatterRegionRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.ScatterRegionRequest) */ {
 public:
  ScatterRegionRequest();
  virtual ~ScatterRegionRequest();

  ScatterRegionRequest(const ScatterRegionRequest& from);
  ScatterRegionRequest(ScatterRegionRequest&& from) noexcept
    : ScatterRegionRequest() {
    *this = ::std::move(from);
  }

  inline ScatterRegionRequest& operator=(const ScatterRegionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScatterRegionRequest& operator=(ScatterRegionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScatterRegionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScatterRegionRequest* internal_default_instance() {
    return reinterpret_cast<const ScatterRegionRequest*>(
               &_ScatterRegionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(ScatterRegionRequest* other);
  friend void swap(ScatterRegionRequest& a, ScatterRegionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScatterRegionRequest* New() const final {
    return CreateMaybeMessage<ScatterRegionRequest>(nullptr);
  }

  ScatterRegionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScatterRegionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScatterRegionRequest& from);
  void MergeFrom(const ScatterRegionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScatterRegionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.ScatterRegionRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // .metapb.Region region = 3;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 3;
  const ::metapb::Region& region() const;
  ::metapb::Region* release_region();
  ::metapb::Region* mutable_region();
  void set_allocated_region(::metapb::Region* region);

  // .metapb.Peer leader = 4;
  bool has_leader() const;
  void clear_leader();
  static const int kLeaderFieldNumber = 4;
  const ::metapb::Peer& leader() const;
  ::metapb::Peer* release_leader();
  ::metapb::Peer* mutable_leader();
  void set_allocated_leader(::metapb::Peer* leader);

  // uint64 region_id = 2;
  void clear_region_id();
  static const int kRegionIdFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.ScatterRegionRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::RequestHeader* header_;
  ::metapb::Region* region_;
  ::metapb::Peer* leader_;
  ::PROTOBUF_NAMESPACE_ID::uint64 region_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class ScatterRegionResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.ScatterRegionResponse) */ {
 public:
  ScatterRegionResponse();
  virtual ~ScatterRegionResponse();

  ScatterRegionResponse(const ScatterRegionResponse& from);
  ScatterRegionResponse(ScatterRegionResponse&& from) noexcept
    : ScatterRegionResponse() {
    *this = ::std::move(from);
  }

  inline ScatterRegionResponse& operator=(const ScatterRegionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScatterRegionResponse& operator=(ScatterRegionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScatterRegionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScatterRegionResponse* internal_default_instance() {
    return reinterpret_cast<const ScatterRegionResponse*>(
               &_ScatterRegionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(ScatterRegionResponse* other);
  friend void swap(ScatterRegionResponse& a, ScatterRegionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScatterRegionResponse* New() const final {
    return CreateMaybeMessage<ScatterRegionResponse>(nullptr);
  }

  ScatterRegionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScatterRegionResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScatterRegionResponse& from);
  void MergeFrom(const ScatterRegionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScatterRegionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.ScatterRegionResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:schedulerpb.ScatterRegionResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class GetGCSafePointRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.GetGCSafePointRequest) */ {
 public:
  GetGCSafePointRequest();
  virtual ~GetGCSafePointRequest();

  GetGCSafePointRequest(const GetGCSafePointRequest& from);
  GetGCSafePointRequest(GetGCSafePointRequest&& from) noexcept
    : GetGCSafePointRequest() {
    *this = ::std::move(from);
  }

  inline GetGCSafePointRequest& operator=(const GetGCSafePointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetGCSafePointRequest& operator=(GetGCSafePointRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetGCSafePointRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetGCSafePointRequest* internal_default_instance() {
    return reinterpret_cast<const GetGCSafePointRequest*>(
               &_GetGCSafePointRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(GetGCSafePointRequest* other);
  friend void swap(GetGCSafePointRequest& a, GetGCSafePointRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetGCSafePointRequest* New() const final {
    return CreateMaybeMessage<GetGCSafePointRequest>(nullptr);
  }

  GetGCSafePointRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetGCSafePointRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetGCSafePointRequest& from);
  void MergeFrom(const GetGCSafePointRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetGCSafePointRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.GetGCSafePointRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:schedulerpb.GetGCSafePointRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class GetGCSafePointResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.GetGCSafePointResponse) */ {
 public:
  GetGCSafePointResponse();
  virtual ~GetGCSafePointResponse();

  GetGCSafePointResponse(const GetGCSafePointResponse& from);
  GetGCSafePointResponse(GetGCSafePointResponse&& from) noexcept
    : GetGCSafePointResponse() {
    *this = ::std::move(from);
  }

  inline GetGCSafePointResponse& operator=(const GetGCSafePointResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetGCSafePointResponse& operator=(GetGCSafePointResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetGCSafePointResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetGCSafePointResponse* internal_default_instance() {
    return reinterpret_cast<const GetGCSafePointResponse*>(
               &_GetGCSafePointResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(GetGCSafePointResponse* other);
  friend void swap(GetGCSafePointResponse& a, GetGCSafePointResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetGCSafePointResponse* New() const final {
    return CreateMaybeMessage<GetGCSafePointResponse>(nullptr);
  }

  GetGCSafePointResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetGCSafePointResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetGCSafePointResponse& from);
  void MergeFrom(const GetGCSafePointResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetGCSafePointResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.GetGCSafePointResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // uint64 safe_point = 2;
  void clear_safe_point();
  static const int kSafePointFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint64 safe_point() const;
  void set_safe_point(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.GetGCSafePointResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::ResponseHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::uint64 safe_point_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class UpdateGCSafePointRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.UpdateGCSafePointRequest) */ {
 public:
  UpdateGCSafePointRequest();
  virtual ~UpdateGCSafePointRequest();

  UpdateGCSafePointRequest(const UpdateGCSafePointRequest& from);
  UpdateGCSafePointRequest(UpdateGCSafePointRequest&& from) noexcept
    : UpdateGCSafePointRequest() {
    *this = ::std::move(from);
  }

  inline UpdateGCSafePointRequest& operator=(const UpdateGCSafePointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateGCSafePointRequest& operator=(UpdateGCSafePointRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateGCSafePointRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateGCSafePointRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateGCSafePointRequest*>(
               &_UpdateGCSafePointRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(UpdateGCSafePointRequest* other);
  friend void swap(UpdateGCSafePointRequest& a, UpdateGCSafePointRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateGCSafePointRequest* New() const final {
    return CreateMaybeMessage<UpdateGCSafePointRequest>(nullptr);
  }

  UpdateGCSafePointRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateGCSafePointRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateGCSafePointRequest& from);
  void MergeFrom(const UpdateGCSafePointRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateGCSafePointRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.UpdateGCSafePointRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // uint64 safe_point = 2;
  void clear_safe_point();
  static const int kSafePointFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint64 safe_point() const;
  void set_safe_point(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.UpdateGCSafePointRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::RequestHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::uint64 safe_point_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class UpdateGCSafePointResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.UpdateGCSafePointResponse) */ {
 public:
  UpdateGCSafePointResponse();
  virtual ~UpdateGCSafePointResponse();

  UpdateGCSafePointResponse(const UpdateGCSafePointResponse& from);
  UpdateGCSafePointResponse(UpdateGCSafePointResponse&& from) noexcept
    : UpdateGCSafePointResponse() {
    *this = ::std::move(from);
  }

  inline UpdateGCSafePointResponse& operator=(const UpdateGCSafePointResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateGCSafePointResponse& operator=(UpdateGCSafePointResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateGCSafePointResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateGCSafePointResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateGCSafePointResponse*>(
               &_UpdateGCSafePointResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(UpdateGCSafePointResponse* other);
  friend void swap(UpdateGCSafePointResponse& a, UpdateGCSafePointResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateGCSafePointResponse* New() const final {
    return CreateMaybeMessage<UpdateGCSafePointResponse>(nullptr);
  }

  UpdateGCSafePointResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateGCSafePointResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateGCSafePointResponse& from);
  void MergeFrom(const UpdateGCSafePointResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateGCSafePointResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.UpdateGCSafePointResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // uint64 new_safe_point = 2;
  void clear_new_safe_point();
  static const int kNewSafePointFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint64 new_safe_point() const;
  void set_new_safe_point(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.UpdateGCSafePointResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::ResponseHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::uint64 new_safe_point_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class GetOperatorRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.GetOperatorRequest) */ {
 public:
  GetOperatorRequest();
  virtual ~GetOperatorRequest();

  GetOperatorRequest(const GetOperatorRequest& from);
  GetOperatorRequest(GetOperatorRequest&& from) noexcept
    : GetOperatorRequest() {
    *this = ::std::move(from);
  }

  inline GetOperatorRequest& operator=(const GetOperatorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOperatorRequest& operator=(GetOperatorRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetOperatorRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetOperatorRequest* internal_default_instance() {
    return reinterpret_cast<const GetOperatorRequest*>(
               &_GetOperatorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(GetOperatorRequest* other);
  friend void swap(GetOperatorRequest& a, GetOperatorRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetOperatorRequest* New() const final {
    return CreateMaybeMessage<GetOperatorRequest>(nullptr);
  }

  GetOperatorRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetOperatorRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetOperatorRequest& from);
  void MergeFrom(const GetOperatorRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOperatorRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.GetOperatorRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .schedulerpb.RequestHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::RequestHeader& header() const;
  ::schedulerpb::RequestHeader* release_header();
  ::schedulerpb::RequestHeader* mutable_header();
  void set_allocated_header(::schedulerpb::RequestHeader* header);

  // uint64 region_id = 2;
  void clear_region_id();
  static const int kRegionIdFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:schedulerpb.GetOperatorRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::schedulerpb::RequestHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::uint64 region_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// -------------------------------------------------------------------

class GetOperatorResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedulerpb.GetOperatorResponse) */ {
 public:
  GetOperatorResponse();
  virtual ~GetOperatorResponse();

  GetOperatorResponse(const GetOperatorResponse& from);
  GetOperatorResponse(GetOperatorResponse&& from) noexcept
    : GetOperatorResponse() {
    *this = ::std::move(from);
  }

  inline GetOperatorResponse& operator=(const GetOperatorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOperatorResponse& operator=(GetOperatorResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetOperatorResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetOperatorResponse* internal_default_instance() {
    return reinterpret_cast<const GetOperatorResponse*>(
               &_GetOperatorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(GetOperatorResponse* other);
  friend void swap(GetOperatorResponse& a, GetOperatorResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetOperatorResponse* New() const final {
    return CreateMaybeMessage<GetOperatorResponse>(nullptr);
  }

  GetOperatorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetOperatorResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetOperatorResponse& from);
  void MergeFrom(const GetOperatorResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOperatorResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedulerpb.GetOperatorResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_schedulerpb_2eproto);
    return ::descriptor_table_schedulerpb_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes desc = 3;
  void clear_desc();
  static const int kDescFieldNumber = 3;
  const std::string& desc() const;
  void set_desc(const std::string& value);
  void set_desc(std::string&& value);
  void set_desc(const char* value);
  void set_desc(const void* value, size_t size);
  std::string* mutable_desc();
  std::string* release_desc();
  void set_allocated_desc(std::string* desc);

  // bytes kind = 5;
  void clear_kind();
  static const int kKindFieldNumber = 5;
  const std::string& kind() const;
  void set_kind(const std::string& value);
  void set_kind(std::string&& value);
  void set_kind(const char* value);
  void set_kind(const void* value, size_t size);
  std::string* mutable_kind();
  std::string* release_kind();
  void set_allocated_kind(std::string* kind);

  // .schedulerpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::schedulerpb::ResponseHeader& header() const;
  ::schedulerpb::ResponseHeader* release_header();
  ::schedulerpb::ResponseHeader* mutable_header();
  void set_allocated_header(::schedulerpb::ResponseHeader* header);

  // uint64 region_id = 2;
  void clear_region_id();
  static const int kRegionIdFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // .schedulerpb.OperatorStatus status = 4;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::schedulerpb::OperatorStatus status() const;
  void set_status(::schedulerpb::OperatorStatus value);

  // @@protoc_insertion_point(class_scope:schedulerpb.GetOperatorResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kind_;
  ::schedulerpb::ResponseHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::uint64 region_id_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_schedulerpb_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RequestHeader

// uint64 cluster_id = 1;
inline void RequestHeader::clear_cluster_id() {
  cluster_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RequestHeader::cluster_id() const {
  // @@protoc_insertion_point(field_get:schedulerpb.RequestHeader.cluster_id)
  return cluster_id_;
}
inline void RequestHeader::set_cluster_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.RequestHeader.cluster_id)
}

// -------------------------------------------------------------------

// ResponseHeader

// uint64 cluster_id = 1;
inline void ResponseHeader::clear_cluster_id() {
  cluster_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ResponseHeader::cluster_id() const {
  // @@protoc_insertion_point(field_get:schedulerpb.ResponseHeader.cluster_id)
  return cluster_id_;
}
inline void ResponseHeader::set_cluster_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.ResponseHeader.cluster_id)
}

// .schedulerpb.Error error = 2;
inline bool ResponseHeader::has_error() const {
  return this != internal_default_instance() && error_ != nullptr;
}
inline void ResponseHeader::clear_error() {
  if (GetArenaNoVirtual() == nullptr && error_ != nullptr) {
    delete error_;
  }
  error_ = nullptr;
}
inline const ::schedulerpb::Error& ResponseHeader::error() const {
  const ::schedulerpb::Error* p = error_;
  // @@protoc_insertion_point(field_get:schedulerpb.ResponseHeader.error)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::Error*>(
      &::schedulerpb::_Error_default_instance_);
}
inline ::schedulerpb::Error* ResponseHeader::release_error() {
  // @@protoc_insertion_point(field_release:schedulerpb.ResponseHeader.error)
  
  ::schedulerpb::Error* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::schedulerpb::Error* ResponseHeader::mutable_error() {
  
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::Error>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.ResponseHeader.error)
  return error_;
}
inline void ResponseHeader::set_allocated_error(::schedulerpb::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.ResponseHeader.error)
}

// -------------------------------------------------------------------

// Error

// .schedulerpb.ErrorType type = 1;
inline void Error::clear_type() {
  type_ = 0;
}
inline ::schedulerpb::ErrorType Error::type() const {
  // @@protoc_insertion_point(field_get:schedulerpb.Error.type)
  return static_cast< ::schedulerpb::ErrorType >(type_);
}
inline void Error::set_type(::schedulerpb::ErrorType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.Error.type)
}

// string message = 2;
inline void Error::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:schedulerpb.Error.message)
  return message_.GetNoArena();
}
inline void Error::set_message(const std::string& value) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schedulerpb.Error.message)
}
inline void Error::set_message(std::string&& value) {
  
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:schedulerpb.Error.message)
}
inline void Error::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schedulerpb.Error.message)
}
inline void Error::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schedulerpb.Error.message)
}
inline std::string* Error::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:schedulerpb.Error.message)
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:schedulerpb.Error.message)
  
  return message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.Error.message)
}

// -------------------------------------------------------------------

// TsoRequest

// .schedulerpb.RequestHeader header = 1;
inline bool TsoRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void TsoRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& TsoRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.TsoRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* TsoRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.TsoRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* TsoRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.TsoRequest.header)
  return header_;
}
inline void TsoRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.TsoRequest.header)
}

// uint32 count = 2;
inline void TsoRequest::clear_count() {
  count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TsoRequest::count() const {
  // @@protoc_insertion_point(field_get:schedulerpb.TsoRequest.count)
  return count_;
}
inline void TsoRequest::set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.TsoRequest.count)
}

// -------------------------------------------------------------------

// Timestamp

// int64 physical = 1;
inline void Timestamp::clear_physical() {
  physical_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Timestamp::physical() const {
  // @@protoc_insertion_point(field_get:schedulerpb.Timestamp.physical)
  return physical_;
}
inline void Timestamp::set_physical(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  physical_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.Timestamp.physical)
}

// int64 logical = 2;
inline void Timestamp::clear_logical() {
  logical_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Timestamp::logical() const {
  // @@protoc_insertion_point(field_get:schedulerpb.Timestamp.logical)
  return logical_;
}
inline void Timestamp::set_logical(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  logical_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.Timestamp.logical)
}

// -------------------------------------------------------------------

// TsoResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool TsoResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void TsoResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& TsoResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.TsoResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* TsoResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.TsoResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* TsoResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.TsoResponse.header)
  return header_;
}
inline void TsoResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.TsoResponse.header)
}

// uint32 count = 2;
inline void TsoResponse::clear_count() {
  count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TsoResponse::count() const {
  // @@protoc_insertion_point(field_get:schedulerpb.TsoResponse.count)
  return count_;
}
inline void TsoResponse::set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.TsoResponse.count)
}

// .schedulerpb.Timestamp timestamp = 3;
inline bool TsoResponse::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline void TsoResponse::clear_timestamp() {
  if (GetArenaNoVirtual() == nullptr && timestamp_ != nullptr) {
    delete timestamp_;
  }
  timestamp_ = nullptr;
}
inline const ::schedulerpb::Timestamp& TsoResponse::timestamp() const {
  const ::schedulerpb::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:schedulerpb.TsoResponse.timestamp)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::Timestamp*>(
      &::schedulerpb::_Timestamp_default_instance_);
}
inline ::schedulerpb::Timestamp* TsoResponse::release_timestamp() {
  // @@protoc_insertion_point(field_release:schedulerpb.TsoResponse.timestamp)
  
  ::schedulerpb::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::schedulerpb::Timestamp* TsoResponse::mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::Timestamp>(GetArenaNoVirtual());
    timestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.TsoResponse.timestamp)
  return timestamp_;
}
inline void TsoResponse::set_allocated_timestamp(::schedulerpb::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete timestamp_;
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.TsoResponse.timestamp)
}

// -------------------------------------------------------------------

// BootstrapRequest

// .schedulerpb.RequestHeader header = 1;
inline bool BootstrapRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void BootstrapRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& BootstrapRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.BootstrapRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* BootstrapRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.BootstrapRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* BootstrapRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.BootstrapRequest.header)
  return header_;
}
inline void BootstrapRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.BootstrapRequest.header)
}

// .metapb.Store store = 2;
inline bool BootstrapRequest::has_store() const {
  return this != internal_default_instance() && store_ != nullptr;
}
inline const ::metapb::Store& BootstrapRequest::store() const {
  const ::metapb::Store* p = store_;
  // @@protoc_insertion_point(field_get:schedulerpb.BootstrapRequest.store)
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::Store*>(
      &::metapb::_Store_default_instance_);
}
inline ::metapb::Store* BootstrapRequest::release_store() {
  // @@protoc_insertion_point(field_release:schedulerpb.BootstrapRequest.store)
  
  ::metapb::Store* temp = store_;
  store_ = nullptr;
  return temp;
}
inline ::metapb::Store* BootstrapRequest::mutable_store() {
  
  if (store_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::Store>(GetArenaNoVirtual());
    store_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.BootstrapRequest.store)
  return store_;
}
inline void BootstrapRequest::set_allocated_store(::metapb::Store* store) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(store_);
  }
  if (store) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      store = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, store, submessage_arena);
    }
    
  } else {
    
  }
  store_ = store;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.BootstrapRequest.store)
}

// -------------------------------------------------------------------

// BootstrapResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool BootstrapResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void BootstrapResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& BootstrapResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.BootstrapResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* BootstrapResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.BootstrapResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* BootstrapResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.BootstrapResponse.header)
  return header_;
}
inline void BootstrapResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.BootstrapResponse.header)
}

// -------------------------------------------------------------------

// IsBootstrappedRequest

// .schedulerpb.RequestHeader header = 1;
inline bool IsBootstrappedRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void IsBootstrappedRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& IsBootstrappedRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.IsBootstrappedRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* IsBootstrappedRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.IsBootstrappedRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* IsBootstrappedRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.IsBootstrappedRequest.header)
  return header_;
}
inline void IsBootstrappedRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.IsBootstrappedRequest.header)
}

// -------------------------------------------------------------------

// IsBootstrappedResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool IsBootstrappedResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void IsBootstrappedResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& IsBootstrappedResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.IsBootstrappedResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* IsBootstrappedResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.IsBootstrappedResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* IsBootstrappedResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.IsBootstrappedResponse.header)
  return header_;
}
inline void IsBootstrappedResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.IsBootstrappedResponse.header)
}

// bool bootstrapped = 2;
inline void IsBootstrappedResponse::clear_bootstrapped() {
  bootstrapped_ = false;
}
inline bool IsBootstrappedResponse::bootstrapped() const {
  // @@protoc_insertion_point(field_get:schedulerpb.IsBootstrappedResponse.bootstrapped)
  return bootstrapped_;
}
inline void IsBootstrappedResponse::set_bootstrapped(bool value) {
  
  bootstrapped_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.IsBootstrappedResponse.bootstrapped)
}

// -------------------------------------------------------------------

// AllocIDRequest

// .schedulerpb.RequestHeader header = 1;
inline bool AllocIDRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void AllocIDRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& AllocIDRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.AllocIDRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* AllocIDRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.AllocIDRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* AllocIDRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.AllocIDRequest.header)
  return header_;
}
inline void AllocIDRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.AllocIDRequest.header)
}

// -------------------------------------------------------------------

// AllocIDResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool AllocIDResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void AllocIDResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& AllocIDResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.AllocIDResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* AllocIDResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.AllocIDResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* AllocIDResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.AllocIDResponse.header)
  return header_;
}
inline void AllocIDResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.AllocIDResponse.header)
}

// uint64 id = 2;
inline void AllocIDResponse::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AllocIDResponse::id() const {
  // @@protoc_insertion_point(field_get:schedulerpb.AllocIDResponse.id)
  return id_;
}
inline void AllocIDResponse::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.AllocIDResponse.id)
}

// -------------------------------------------------------------------

// GetStoreRequest

// .schedulerpb.RequestHeader header = 1;
inline bool GetStoreRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetStoreRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& GetStoreRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetStoreRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* GetStoreRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetStoreRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* GetStoreRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetStoreRequest.header)
  return header_;
}
inline void GetStoreRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetStoreRequest.header)
}

// uint64 store_id = 2;
inline void GetStoreRequest::clear_store_id() {
  store_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetStoreRequest::store_id() const {
  // @@protoc_insertion_point(field_get:schedulerpb.GetStoreRequest.store_id)
  return store_id_;
}
inline void GetStoreRequest::set_store_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  store_id_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.GetStoreRequest.store_id)
}

// -------------------------------------------------------------------

// GetStoreResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool GetStoreResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetStoreResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& GetStoreResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetStoreResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* GetStoreResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetStoreResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* GetStoreResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetStoreResponse.header)
  return header_;
}
inline void GetStoreResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetStoreResponse.header)
}

// .metapb.Store store = 2;
inline bool GetStoreResponse::has_store() const {
  return this != internal_default_instance() && store_ != nullptr;
}
inline const ::metapb::Store& GetStoreResponse::store() const {
  const ::metapb::Store* p = store_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetStoreResponse.store)
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::Store*>(
      &::metapb::_Store_default_instance_);
}
inline ::metapb::Store* GetStoreResponse::release_store() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetStoreResponse.store)
  
  ::metapb::Store* temp = store_;
  store_ = nullptr;
  return temp;
}
inline ::metapb::Store* GetStoreResponse::mutable_store() {
  
  if (store_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::Store>(GetArenaNoVirtual());
    store_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetStoreResponse.store)
  return store_;
}
inline void GetStoreResponse::set_allocated_store(::metapb::Store* store) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(store_);
  }
  if (store) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      store = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, store, submessage_arena);
    }
    
  } else {
    
  }
  store_ = store;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetStoreResponse.store)
}

// .schedulerpb.StoreStats stats = 3;
inline bool GetStoreResponse::has_stats() const {
  return this != internal_default_instance() && stats_ != nullptr;
}
inline void GetStoreResponse::clear_stats() {
  if (GetArenaNoVirtual() == nullptr && stats_ != nullptr) {
    delete stats_;
  }
  stats_ = nullptr;
}
inline const ::schedulerpb::StoreStats& GetStoreResponse::stats() const {
  const ::schedulerpb::StoreStats* p = stats_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetStoreResponse.stats)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::StoreStats*>(
      &::schedulerpb::_StoreStats_default_instance_);
}
inline ::schedulerpb::StoreStats* GetStoreResponse::release_stats() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetStoreResponse.stats)
  
  ::schedulerpb::StoreStats* temp = stats_;
  stats_ = nullptr;
  return temp;
}
inline ::schedulerpb::StoreStats* GetStoreResponse::mutable_stats() {
  
  if (stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::StoreStats>(GetArenaNoVirtual());
    stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetStoreResponse.stats)
  return stats_;
}
inline void GetStoreResponse::set_allocated_stats(::schedulerpb::StoreStats* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete stats_;
  }
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetStoreResponse.stats)
}

// -------------------------------------------------------------------

// PutStoreRequest

// .schedulerpb.RequestHeader header = 1;
inline bool PutStoreRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void PutStoreRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& PutStoreRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.PutStoreRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* PutStoreRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.PutStoreRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* PutStoreRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.PutStoreRequest.header)
  return header_;
}
inline void PutStoreRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.PutStoreRequest.header)
}

// .metapb.Store store = 2;
inline bool PutStoreRequest::has_store() const {
  return this != internal_default_instance() && store_ != nullptr;
}
inline const ::metapb::Store& PutStoreRequest::store() const {
  const ::metapb::Store* p = store_;
  // @@protoc_insertion_point(field_get:schedulerpb.PutStoreRequest.store)
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::Store*>(
      &::metapb::_Store_default_instance_);
}
inline ::metapb::Store* PutStoreRequest::release_store() {
  // @@protoc_insertion_point(field_release:schedulerpb.PutStoreRequest.store)
  
  ::metapb::Store* temp = store_;
  store_ = nullptr;
  return temp;
}
inline ::metapb::Store* PutStoreRequest::mutable_store() {
  
  if (store_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::Store>(GetArenaNoVirtual());
    store_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.PutStoreRequest.store)
  return store_;
}
inline void PutStoreRequest::set_allocated_store(::metapb::Store* store) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(store_);
  }
  if (store) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      store = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, store, submessage_arena);
    }
    
  } else {
    
  }
  store_ = store;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.PutStoreRequest.store)
}

// -------------------------------------------------------------------

// PutStoreResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool PutStoreResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void PutStoreResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& PutStoreResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.PutStoreResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* PutStoreResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.PutStoreResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* PutStoreResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.PutStoreResponse.header)
  return header_;
}
inline void PutStoreResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.PutStoreResponse.header)
}

// -------------------------------------------------------------------

// GetAllStoresRequest

// .schedulerpb.RequestHeader header = 1;
inline bool GetAllStoresRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetAllStoresRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& GetAllStoresRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetAllStoresRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* GetAllStoresRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetAllStoresRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* GetAllStoresRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetAllStoresRequest.header)
  return header_;
}
inline void GetAllStoresRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetAllStoresRequest.header)
}

// bool exclude_tombstone_stores = 2;
inline void GetAllStoresRequest::clear_exclude_tombstone_stores() {
  exclude_tombstone_stores_ = false;
}
inline bool GetAllStoresRequest::exclude_tombstone_stores() const {
  // @@protoc_insertion_point(field_get:schedulerpb.GetAllStoresRequest.exclude_tombstone_stores)
  return exclude_tombstone_stores_;
}
inline void GetAllStoresRequest::set_exclude_tombstone_stores(bool value) {
  
  exclude_tombstone_stores_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.GetAllStoresRequest.exclude_tombstone_stores)
}

// -------------------------------------------------------------------

// GetAllStoresResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool GetAllStoresResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetAllStoresResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& GetAllStoresResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetAllStoresResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* GetAllStoresResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetAllStoresResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* GetAllStoresResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetAllStoresResponse.header)
  return header_;
}
inline void GetAllStoresResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetAllStoresResponse.header)
}

// repeated .metapb.Store stores = 2;
inline int GetAllStoresResponse::stores_size() const {
  return stores_.size();
}
inline ::metapb::Store* GetAllStoresResponse::mutable_stores(int index) {
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetAllStoresResponse.stores)
  return stores_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Store >*
GetAllStoresResponse::mutable_stores() {
  // @@protoc_insertion_point(field_mutable_list:schedulerpb.GetAllStoresResponse.stores)
  return &stores_;
}
inline const ::metapb::Store& GetAllStoresResponse::stores(int index) const {
  // @@protoc_insertion_point(field_get:schedulerpb.GetAllStoresResponse.stores)
  return stores_.Get(index);
}
inline ::metapb::Store* GetAllStoresResponse::add_stores() {
  // @@protoc_insertion_point(field_add:schedulerpb.GetAllStoresResponse.stores)
  return stores_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Store >&
GetAllStoresResponse::stores() const {
  // @@protoc_insertion_point(field_list:schedulerpb.GetAllStoresResponse.stores)
  return stores_;
}

// -------------------------------------------------------------------

// GetRegionRequest

// .schedulerpb.RequestHeader header = 1;
inline bool GetRegionRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetRegionRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& GetRegionRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetRegionRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* GetRegionRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetRegionRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* GetRegionRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetRegionRequest.header)
  return header_;
}
inline void GetRegionRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetRegionRequest.header)
}

// bytes region_key = 2;
inline void GetRegionRequest::clear_region_key() {
  region_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GetRegionRequest::region_key() const {
  // @@protoc_insertion_point(field_get:schedulerpb.GetRegionRequest.region_key)
  return region_key_.GetNoArena();
}
inline void GetRegionRequest::set_region_key(const std::string& value) {
  
  region_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schedulerpb.GetRegionRequest.region_key)
}
inline void GetRegionRequest::set_region_key(std::string&& value) {
  
  region_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:schedulerpb.GetRegionRequest.region_key)
}
inline void GetRegionRequest::set_region_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  region_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schedulerpb.GetRegionRequest.region_key)
}
inline void GetRegionRequest::set_region_key(const void* value, size_t size) {
  
  region_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schedulerpb.GetRegionRequest.region_key)
}
inline std::string* GetRegionRequest::mutable_region_key() {
  
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetRegionRequest.region_key)
  return region_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetRegionRequest::release_region_key() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetRegionRequest.region_key)
  
  return region_key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetRegionRequest::set_allocated_region_key(std::string* region_key) {
  if (region_key != nullptr) {
    
  } else {
    
  }
  region_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region_key);
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetRegionRequest.region_key)
}

// -------------------------------------------------------------------

// GetRegionResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool GetRegionResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetRegionResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& GetRegionResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetRegionResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* GetRegionResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetRegionResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* GetRegionResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetRegionResponse.header)
  return header_;
}
inline void GetRegionResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetRegionResponse.header)
}

// .metapb.Region region = 2;
inline bool GetRegionResponse::has_region() const {
  return this != internal_default_instance() && region_ != nullptr;
}
inline const ::metapb::Region& GetRegionResponse::region() const {
  const ::metapb::Region* p = region_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetRegionResponse.region)
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::Region*>(
      &::metapb::_Region_default_instance_);
}
inline ::metapb::Region* GetRegionResponse::release_region() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetRegionResponse.region)
  
  ::metapb::Region* temp = region_;
  region_ = nullptr;
  return temp;
}
inline ::metapb::Region* GetRegionResponse::mutable_region() {
  
  if (region_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::Region>(GetArenaNoVirtual());
    region_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetRegionResponse.region)
  return region_;
}
inline void GetRegionResponse::set_allocated_region(::metapb::Region* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_);
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    
  } else {
    
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetRegionResponse.region)
}

// .metapb.Peer leader = 3;
inline bool GetRegionResponse::has_leader() const {
  return this != internal_default_instance() && leader_ != nullptr;
}
inline const ::metapb::Peer& GetRegionResponse::leader() const {
  const ::metapb::Peer* p = leader_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetRegionResponse.leader)
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::Peer*>(
      &::metapb::_Peer_default_instance_);
}
inline ::metapb::Peer* GetRegionResponse::release_leader() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetRegionResponse.leader)
  
  ::metapb::Peer* temp = leader_;
  leader_ = nullptr;
  return temp;
}
inline ::metapb::Peer* GetRegionResponse::mutable_leader() {
  
  if (leader_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::Peer>(GetArenaNoVirtual());
    leader_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetRegionResponse.leader)
  return leader_;
}
inline void GetRegionResponse::set_allocated_leader(::metapb::Peer* leader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader_);
  }
  if (leader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      leader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leader, submessage_arena);
    }
    
  } else {
    
  }
  leader_ = leader;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetRegionResponse.leader)
}

// repeated .metapb.Peer slaves = 4;
inline int GetRegionResponse::slaves_size() const {
  return slaves_.size();
}
inline ::metapb::Peer* GetRegionResponse::mutable_slaves(int index) {
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetRegionResponse.slaves)
  return slaves_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Peer >*
GetRegionResponse::mutable_slaves() {
  // @@protoc_insertion_point(field_mutable_list:schedulerpb.GetRegionResponse.slaves)
  return &slaves_;
}
inline const ::metapb::Peer& GetRegionResponse::slaves(int index) const {
  // @@protoc_insertion_point(field_get:schedulerpb.GetRegionResponse.slaves)
  return slaves_.Get(index);
}
inline ::metapb::Peer* GetRegionResponse::add_slaves() {
  // @@protoc_insertion_point(field_add:schedulerpb.GetRegionResponse.slaves)
  return slaves_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Peer >&
GetRegionResponse::slaves() const {
  // @@protoc_insertion_point(field_list:schedulerpb.GetRegionResponse.slaves)
  return slaves_;
}

// -------------------------------------------------------------------

// GetRegionByIDRequest

// .schedulerpb.RequestHeader header = 1;
inline bool GetRegionByIDRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetRegionByIDRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& GetRegionByIDRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetRegionByIDRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* GetRegionByIDRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetRegionByIDRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* GetRegionByIDRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetRegionByIDRequest.header)
  return header_;
}
inline void GetRegionByIDRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetRegionByIDRequest.header)
}

// uint64 region_id = 2;
inline void GetRegionByIDRequest::clear_region_id() {
  region_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetRegionByIDRequest::region_id() const {
  // @@protoc_insertion_point(field_get:schedulerpb.GetRegionByIDRequest.region_id)
  return region_id_;
}
inline void GetRegionByIDRequest::set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  region_id_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.GetRegionByIDRequest.region_id)
}

// -------------------------------------------------------------------

// ScanRegionsRequest

// .schedulerpb.RequestHeader header = 1;
inline bool ScanRegionsRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void ScanRegionsRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& ScanRegionsRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.ScanRegionsRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* ScanRegionsRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.ScanRegionsRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* ScanRegionsRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.ScanRegionsRequest.header)
  return header_;
}
inline void ScanRegionsRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.ScanRegionsRequest.header)
}

// bytes start_key = 2;
inline void ScanRegionsRequest::clear_start_key() {
  start_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ScanRegionsRequest::start_key() const {
  // @@protoc_insertion_point(field_get:schedulerpb.ScanRegionsRequest.start_key)
  return start_key_.GetNoArena();
}
inline void ScanRegionsRequest::set_start_key(const std::string& value) {
  
  start_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schedulerpb.ScanRegionsRequest.start_key)
}
inline void ScanRegionsRequest::set_start_key(std::string&& value) {
  
  start_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:schedulerpb.ScanRegionsRequest.start_key)
}
inline void ScanRegionsRequest::set_start_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  start_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schedulerpb.ScanRegionsRequest.start_key)
}
inline void ScanRegionsRequest::set_start_key(const void* value, size_t size) {
  
  start_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schedulerpb.ScanRegionsRequest.start_key)
}
inline std::string* ScanRegionsRequest::mutable_start_key() {
  
  // @@protoc_insertion_point(field_mutable:schedulerpb.ScanRegionsRequest.start_key)
  return start_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ScanRegionsRequest::release_start_key() {
  // @@protoc_insertion_point(field_release:schedulerpb.ScanRegionsRequest.start_key)
  
  return start_key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ScanRegionsRequest::set_allocated_start_key(std::string* start_key) {
  if (start_key != nullptr) {
    
  } else {
    
  }
  start_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), start_key);
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.ScanRegionsRequest.start_key)
}

// int32 limit = 3;
inline void ScanRegionsRequest::clear_limit() {
  limit_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ScanRegionsRequest::limit() const {
  // @@protoc_insertion_point(field_get:schedulerpb.ScanRegionsRequest.limit)
  return limit_;
}
inline void ScanRegionsRequest::set_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.ScanRegionsRequest.limit)
}

// bytes end_key = 4;
inline void ScanRegionsRequest::clear_end_key() {
  end_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ScanRegionsRequest::end_key() const {
  // @@protoc_insertion_point(field_get:schedulerpb.ScanRegionsRequest.end_key)
  return end_key_.GetNoArena();
}
inline void ScanRegionsRequest::set_end_key(const std::string& value) {
  
  end_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schedulerpb.ScanRegionsRequest.end_key)
}
inline void ScanRegionsRequest::set_end_key(std::string&& value) {
  
  end_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:schedulerpb.ScanRegionsRequest.end_key)
}
inline void ScanRegionsRequest::set_end_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  end_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schedulerpb.ScanRegionsRequest.end_key)
}
inline void ScanRegionsRequest::set_end_key(const void* value, size_t size) {
  
  end_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schedulerpb.ScanRegionsRequest.end_key)
}
inline std::string* ScanRegionsRequest::mutable_end_key() {
  
  // @@protoc_insertion_point(field_mutable:schedulerpb.ScanRegionsRequest.end_key)
  return end_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ScanRegionsRequest::release_end_key() {
  // @@protoc_insertion_point(field_release:schedulerpb.ScanRegionsRequest.end_key)
  
  return end_key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ScanRegionsRequest::set_allocated_end_key(std::string* end_key) {
  if (end_key != nullptr) {
    
  } else {
    
  }
  end_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), end_key);
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.ScanRegionsRequest.end_key)
}

// -------------------------------------------------------------------

// ScanRegionsResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool ScanRegionsResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void ScanRegionsResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& ScanRegionsResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.ScanRegionsResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* ScanRegionsResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.ScanRegionsResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* ScanRegionsResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.ScanRegionsResponse.header)
  return header_;
}
inline void ScanRegionsResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.ScanRegionsResponse.header)
}

// repeated .metapb.Region regions = 2;
inline int ScanRegionsResponse::regions_size() const {
  return regions_.size();
}
inline ::metapb::Region* ScanRegionsResponse::mutable_regions(int index) {
  // @@protoc_insertion_point(field_mutable:schedulerpb.ScanRegionsResponse.regions)
  return regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Region >*
ScanRegionsResponse::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_list:schedulerpb.ScanRegionsResponse.regions)
  return &regions_;
}
inline const ::metapb::Region& ScanRegionsResponse::regions(int index) const {
  // @@protoc_insertion_point(field_get:schedulerpb.ScanRegionsResponse.regions)
  return regions_.Get(index);
}
inline ::metapb::Region* ScanRegionsResponse::add_regions() {
  // @@protoc_insertion_point(field_add:schedulerpb.ScanRegionsResponse.regions)
  return regions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Region >&
ScanRegionsResponse::regions() const {
  // @@protoc_insertion_point(field_list:schedulerpb.ScanRegionsResponse.regions)
  return regions_;
}

// repeated .metapb.Peer leaders = 3;
inline int ScanRegionsResponse::leaders_size() const {
  return leaders_.size();
}
inline ::metapb::Peer* ScanRegionsResponse::mutable_leaders(int index) {
  // @@protoc_insertion_point(field_mutable:schedulerpb.ScanRegionsResponse.leaders)
  return leaders_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Peer >*
ScanRegionsResponse::mutable_leaders() {
  // @@protoc_insertion_point(field_mutable_list:schedulerpb.ScanRegionsResponse.leaders)
  return &leaders_;
}
inline const ::metapb::Peer& ScanRegionsResponse::leaders(int index) const {
  // @@protoc_insertion_point(field_get:schedulerpb.ScanRegionsResponse.leaders)
  return leaders_.Get(index);
}
inline ::metapb::Peer* ScanRegionsResponse::add_leaders() {
  // @@protoc_insertion_point(field_add:schedulerpb.ScanRegionsResponse.leaders)
  return leaders_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Peer >&
ScanRegionsResponse::leaders() const {
  // @@protoc_insertion_point(field_list:schedulerpb.ScanRegionsResponse.leaders)
  return leaders_;
}

// -------------------------------------------------------------------

// GetClusterConfigRequest

// .schedulerpb.RequestHeader header = 1;
inline bool GetClusterConfigRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetClusterConfigRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& GetClusterConfigRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetClusterConfigRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* GetClusterConfigRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetClusterConfigRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* GetClusterConfigRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetClusterConfigRequest.header)
  return header_;
}
inline void GetClusterConfigRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetClusterConfigRequest.header)
}

// -------------------------------------------------------------------

// GetClusterConfigResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool GetClusterConfigResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetClusterConfigResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& GetClusterConfigResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetClusterConfigResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* GetClusterConfigResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetClusterConfigResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* GetClusterConfigResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetClusterConfigResponse.header)
  return header_;
}
inline void GetClusterConfigResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetClusterConfigResponse.header)
}

// .metapb.Cluster cluster = 2;
inline bool GetClusterConfigResponse::has_cluster() const {
  return this != internal_default_instance() && cluster_ != nullptr;
}
inline const ::metapb::Cluster& GetClusterConfigResponse::cluster() const {
  const ::metapb::Cluster* p = cluster_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetClusterConfigResponse.cluster)
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::Cluster*>(
      &::metapb::_Cluster_default_instance_);
}
inline ::metapb::Cluster* GetClusterConfigResponse::release_cluster() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetClusterConfigResponse.cluster)
  
  ::metapb::Cluster* temp = cluster_;
  cluster_ = nullptr;
  return temp;
}
inline ::metapb::Cluster* GetClusterConfigResponse::mutable_cluster() {
  
  if (cluster_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::Cluster>(GetArenaNoVirtual());
    cluster_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetClusterConfigResponse.cluster)
  return cluster_;
}
inline void GetClusterConfigResponse::set_allocated_cluster(::metapb::Cluster* cluster) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cluster_);
  }
  if (cluster) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cluster = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cluster, submessage_arena);
    }
    
  } else {
    
  }
  cluster_ = cluster;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetClusterConfigResponse.cluster)
}

// -------------------------------------------------------------------

// PutClusterConfigRequest

// .schedulerpb.RequestHeader header = 1;
inline bool PutClusterConfigRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void PutClusterConfigRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& PutClusterConfigRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.PutClusterConfigRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* PutClusterConfigRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.PutClusterConfigRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* PutClusterConfigRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.PutClusterConfigRequest.header)
  return header_;
}
inline void PutClusterConfigRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.PutClusterConfigRequest.header)
}

// .metapb.Cluster cluster = 2;
inline bool PutClusterConfigRequest::has_cluster() const {
  return this != internal_default_instance() && cluster_ != nullptr;
}
inline const ::metapb::Cluster& PutClusterConfigRequest::cluster() const {
  const ::metapb::Cluster* p = cluster_;
  // @@protoc_insertion_point(field_get:schedulerpb.PutClusterConfigRequest.cluster)
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::Cluster*>(
      &::metapb::_Cluster_default_instance_);
}
inline ::metapb::Cluster* PutClusterConfigRequest::release_cluster() {
  // @@protoc_insertion_point(field_release:schedulerpb.PutClusterConfigRequest.cluster)
  
  ::metapb::Cluster* temp = cluster_;
  cluster_ = nullptr;
  return temp;
}
inline ::metapb::Cluster* PutClusterConfigRequest::mutable_cluster() {
  
  if (cluster_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::Cluster>(GetArenaNoVirtual());
    cluster_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.PutClusterConfigRequest.cluster)
  return cluster_;
}
inline void PutClusterConfigRequest::set_allocated_cluster(::metapb::Cluster* cluster) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cluster_);
  }
  if (cluster) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cluster = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cluster, submessage_arena);
    }
    
  } else {
    
  }
  cluster_ = cluster;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.PutClusterConfigRequest.cluster)
}

// -------------------------------------------------------------------

// PutClusterConfigResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool PutClusterConfigResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void PutClusterConfigResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& PutClusterConfigResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.PutClusterConfigResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* PutClusterConfigResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.PutClusterConfigResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* PutClusterConfigResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.PutClusterConfigResponse.header)
  return header_;
}
inline void PutClusterConfigResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.PutClusterConfigResponse.header)
}

// -------------------------------------------------------------------

// Member

// string name = 1;
inline void Member::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Member::name() const {
  // @@protoc_insertion_point(field_get:schedulerpb.Member.name)
  return name_.GetNoArena();
}
inline void Member::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schedulerpb.Member.name)
}
inline void Member::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:schedulerpb.Member.name)
}
inline void Member::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schedulerpb.Member.name)
}
inline void Member::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schedulerpb.Member.name)
}
inline std::string* Member::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:schedulerpb.Member.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Member::release_name() {
  // @@protoc_insertion_point(field_release:schedulerpb.Member.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Member::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.Member.name)
}

// uint64 member_id = 2;
inline void Member::clear_member_id() {
  member_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Member::member_id() const {
  // @@protoc_insertion_point(field_get:schedulerpb.Member.member_id)
  return member_id_;
}
inline void Member::set_member_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  member_id_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.Member.member_id)
}

// repeated string peer_urls = 3;
inline int Member::peer_urls_size() const {
  return peer_urls_.size();
}
inline void Member::clear_peer_urls() {
  peer_urls_.Clear();
}
inline const std::string& Member::peer_urls(int index) const {
  // @@protoc_insertion_point(field_get:schedulerpb.Member.peer_urls)
  return peer_urls_.Get(index);
}
inline std::string* Member::mutable_peer_urls(int index) {
  // @@protoc_insertion_point(field_mutable:schedulerpb.Member.peer_urls)
  return peer_urls_.Mutable(index);
}
inline void Member::set_peer_urls(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:schedulerpb.Member.peer_urls)
  peer_urls_.Mutable(index)->assign(value);
}
inline void Member::set_peer_urls(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:schedulerpb.Member.peer_urls)
  peer_urls_.Mutable(index)->assign(std::move(value));
}
inline void Member::set_peer_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  peer_urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:schedulerpb.Member.peer_urls)
}
inline void Member::set_peer_urls(int index, const char* value, size_t size) {
  peer_urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:schedulerpb.Member.peer_urls)
}
inline std::string* Member::add_peer_urls() {
  // @@protoc_insertion_point(field_add_mutable:schedulerpb.Member.peer_urls)
  return peer_urls_.Add();
}
inline void Member::add_peer_urls(const std::string& value) {
  peer_urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:schedulerpb.Member.peer_urls)
}
inline void Member::add_peer_urls(std::string&& value) {
  peer_urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:schedulerpb.Member.peer_urls)
}
inline void Member::add_peer_urls(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  peer_urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:schedulerpb.Member.peer_urls)
}
inline void Member::add_peer_urls(const char* value, size_t size) {
  peer_urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:schedulerpb.Member.peer_urls)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Member::peer_urls() const {
  // @@protoc_insertion_point(field_list:schedulerpb.Member.peer_urls)
  return peer_urls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Member::mutable_peer_urls() {
  // @@protoc_insertion_point(field_mutable_list:schedulerpb.Member.peer_urls)
  return &peer_urls_;
}

// repeated string client_urls = 4;
inline int Member::client_urls_size() const {
  return client_urls_.size();
}
inline void Member::clear_client_urls() {
  client_urls_.Clear();
}
inline const std::string& Member::client_urls(int index) const {
  // @@protoc_insertion_point(field_get:schedulerpb.Member.client_urls)
  return client_urls_.Get(index);
}
inline std::string* Member::mutable_client_urls(int index) {
  // @@protoc_insertion_point(field_mutable:schedulerpb.Member.client_urls)
  return client_urls_.Mutable(index);
}
inline void Member::set_client_urls(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:schedulerpb.Member.client_urls)
  client_urls_.Mutable(index)->assign(value);
}
inline void Member::set_client_urls(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:schedulerpb.Member.client_urls)
  client_urls_.Mutable(index)->assign(std::move(value));
}
inline void Member::set_client_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  client_urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:schedulerpb.Member.client_urls)
}
inline void Member::set_client_urls(int index, const char* value, size_t size) {
  client_urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:schedulerpb.Member.client_urls)
}
inline std::string* Member::add_client_urls() {
  // @@protoc_insertion_point(field_add_mutable:schedulerpb.Member.client_urls)
  return client_urls_.Add();
}
inline void Member::add_client_urls(const std::string& value) {
  client_urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:schedulerpb.Member.client_urls)
}
inline void Member::add_client_urls(std::string&& value) {
  client_urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:schedulerpb.Member.client_urls)
}
inline void Member::add_client_urls(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  client_urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:schedulerpb.Member.client_urls)
}
inline void Member::add_client_urls(const char* value, size_t size) {
  client_urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:schedulerpb.Member.client_urls)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Member::client_urls() const {
  // @@protoc_insertion_point(field_list:schedulerpb.Member.client_urls)
  return client_urls_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Member::mutable_client_urls() {
  // @@protoc_insertion_point(field_mutable_list:schedulerpb.Member.client_urls)
  return &client_urls_;
}

// int32 leader_priority = 5;
inline void Member::clear_leader_priority() {
  leader_priority_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Member::leader_priority() const {
  // @@protoc_insertion_point(field_get:schedulerpb.Member.leader_priority)
  return leader_priority_;
}
inline void Member::set_leader_priority(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  leader_priority_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.Member.leader_priority)
}

// -------------------------------------------------------------------

// GetMembersRequest

// .schedulerpb.RequestHeader header = 1;
inline bool GetMembersRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetMembersRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& GetMembersRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetMembersRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* GetMembersRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetMembersRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* GetMembersRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetMembersRequest.header)
  return header_;
}
inline void GetMembersRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetMembersRequest.header)
}

// -------------------------------------------------------------------

// GetMembersResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool GetMembersResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetMembersResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& GetMembersResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetMembersResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* GetMembersResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetMembersResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* GetMembersResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetMembersResponse.header)
  return header_;
}
inline void GetMembersResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetMembersResponse.header)
}

// repeated .schedulerpb.Member members = 2;
inline int GetMembersResponse::members_size() const {
  return members_.size();
}
inline void GetMembersResponse::clear_members() {
  members_.Clear();
}
inline ::schedulerpb::Member* GetMembersResponse::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetMembersResponse.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::Member >*
GetMembersResponse::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:schedulerpb.GetMembersResponse.members)
  return &members_;
}
inline const ::schedulerpb::Member& GetMembersResponse::members(int index) const {
  // @@protoc_insertion_point(field_get:schedulerpb.GetMembersResponse.members)
  return members_.Get(index);
}
inline ::schedulerpb::Member* GetMembersResponse::add_members() {
  // @@protoc_insertion_point(field_add:schedulerpb.GetMembersResponse.members)
  return members_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::Member >&
GetMembersResponse::members() const {
  // @@protoc_insertion_point(field_list:schedulerpb.GetMembersResponse.members)
  return members_;
}

// .schedulerpb.Member leader = 3;
inline bool GetMembersResponse::has_leader() const {
  return this != internal_default_instance() && leader_ != nullptr;
}
inline void GetMembersResponse::clear_leader() {
  if (GetArenaNoVirtual() == nullptr && leader_ != nullptr) {
    delete leader_;
  }
  leader_ = nullptr;
}
inline const ::schedulerpb::Member& GetMembersResponse::leader() const {
  const ::schedulerpb::Member* p = leader_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetMembersResponse.leader)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::Member*>(
      &::schedulerpb::_Member_default_instance_);
}
inline ::schedulerpb::Member* GetMembersResponse::release_leader() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetMembersResponse.leader)
  
  ::schedulerpb::Member* temp = leader_;
  leader_ = nullptr;
  return temp;
}
inline ::schedulerpb::Member* GetMembersResponse::mutable_leader() {
  
  if (leader_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::Member>(GetArenaNoVirtual());
    leader_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetMembersResponse.leader)
  return leader_;
}
inline void GetMembersResponse::set_allocated_leader(::schedulerpb::Member* leader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete leader_;
  }
  if (leader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      leader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leader, submessage_arena);
    }
    
  } else {
    
  }
  leader_ = leader;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetMembersResponse.leader)
}

// .schedulerpb.Member etcd_leader = 4;
inline bool GetMembersResponse::has_etcd_leader() const {
  return this != internal_default_instance() && etcd_leader_ != nullptr;
}
inline void GetMembersResponse::clear_etcd_leader() {
  if (GetArenaNoVirtual() == nullptr && etcd_leader_ != nullptr) {
    delete etcd_leader_;
  }
  etcd_leader_ = nullptr;
}
inline const ::schedulerpb::Member& GetMembersResponse::etcd_leader() const {
  const ::schedulerpb::Member* p = etcd_leader_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetMembersResponse.etcd_leader)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::Member*>(
      &::schedulerpb::_Member_default_instance_);
}
inline ::schedulerpb::Member* GetMembersResponse::release_etcd_leader() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetMembersResponse.etcd_leader)
  
  ::schedulerpb::Member* temp = etcd_leader_;
  etcd_leader_ = nullptr;
  return temp;
}
inline ::schedulerpb::Member* GetMembersResponse::mutable_etcd_leader() {
  
  if (etcd_leader_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::Member>(GetArenaNoVirtual());
    etcd_leader_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetMembersResponse.etcd_leader)
  return etcd_leader_;
}
inline void GetMembersResponse::set_allocated_etcd_leader(::schedulerpb::Member* etcd_leader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete etcd_leader_;
  }
  if (etcd_leader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      etcd_leader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, etcd_leader, submessage_arena);
    }
    
  } else {
    
  }
  etcd_leader_ = etcd_leader;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetMembersResponse.etcd_leader)
}

// -------------------------------------------------------------------

// RegionHeartbeatRequest

// .schedulerpb.RequestHeader header = 1;
inline bool RegionHeartbeatRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void RegionHeartbeatRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& RegionHeartbeatRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.RegionHeartbeatRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* RegionHeartbeatRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.RegionHeartbeatRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* RegionHeartbeatRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.RegionHeartbeatRequest.header)
  return header_;
}
inline void RegionHeartbeatRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.RegionHeartbeatRequest.header)
}

// .metapb.Region region = 2;
inline bool RegionHeartbeatRequest::has_region() const {
  return this != internal_default_instance() && region_ != nullptr;
}
inline const ::metapb::Region& RegionHeartbeatRequest::region() const {
  const ::metapb::Region* p = region_;
  // @@protoc_insertion_point(field_get:schedulerpb.RegionHeartbeatRequest.region)
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::Region*>(
      &::metapb::_Region_default_instance_);
}
inline ::metapb::Region* RegionHeartbeatRequest::release_region() {
  // @@protoc_insertion_point(field_release:schedulerpb.RegionHeartbeatRequest.region)
  
  ::metapb::Region* temp = region_;
  region_ = nullptr;
  return temp;
}
inline ::metapb::Region* RegionHeartbeatRequest::mutable_region() {
  
  if (region_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::Region>(GetArenaNoVirtual());
    region_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.RegionHeartbeatRequest.region)
  return region_;
}
inline void RegionHeartbeatRequest::set_allocated_region(::metapb::Region* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_);
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    
  } else {
    
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.RegionHeartbeatRequest.region)
}

// .metapb.Peer leader = 3;
inline bool RegionHeartbeatRequest::has_leader() const {
  return this != internal_default_instance() && leader_ != nullptr;
}
inline const ::metapb::Peer& RegionHeartbeatRequest::leader() const {
  const ::metapb::Peer* p = leader_;
  // @@protoc_insertion_point(field_get:schedulerpb.RegionHeartbeatRequest.leader)
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::Peer*>(
      &::metapb::_Peer_default_instance_);
}
inline ::metapb::Peer* RegionHeartbeatRequest::release_leader() {
  // @@protoc_insertion_point(field_release:schedulerpb.RegionHeartbeatRequest.leader)
  
  ::metapb::Peer* temp = leader_;
  leader_ = nullptr;
  return temp;
}
inline ::metapb::Peer* RegionHeartbeatRequest::mutable_leader() {
  
  if (leader_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::Peer>(GetArenaNoVirtual());
    leader_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.RegionHeartbeatRequest.leader)
  return leader_;
}
inline void RegionHeartbeatRequest::set_allocated_leader(::metapb::Peer* leader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader_);
  }
  if (leader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      leader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leader, submessage_arena);
    }
    
  } else {
    
  }
  leader_ = leader;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.RegionHeartbeatRequest.leader)
}

// repeated .metapb.Peer pending_peers = 5;
inline int RegionHeartbeatRequest::pending_peers_size() const {
  return pending_peers_.size();
}
inline ::metapb::Peer* RegionHeartbeatRequest::mutable_pending_peers(int index) {
  // @@protoc_insertion_point(field_mutable:schedulerpb.RegionHeartbeatRequest.pending_peers)
  return pending_peers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Peer >*
RegionHeartbeatRequest::mutable_pending_peers() {
  // @@protoc_insertion_point(field_mutable_list:schedulerpb.RegionHeartbeatRequest.pending_peers)
  return &pending_peers_;
}
inline const ::metapb::Peer& RegionHeartbeatRequest::pending_peers(int index) const {
  // @@protoc_insertion_point(field_get:schedulerpb.RegionHeartbeatRequest.pending_peers)
  return pending_peers_.Get(index);
}
inline ::metapb::Peer* RegionHeartbeatRequest::add_pending_peers() {
  // @@protoc_insertion_point(field_add:schedulerpb.RegionHeartbeatRequest.pending_peers)
  return pending_peers_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metapb::Peer >&
RegionHeartbeatRequest::pending_peers() const {
  // @@protoc_insertion_point(field_list:schedulerpb.RegionHeartbeatRequest.pending_peers)
  return pending_peers_;
}

// uint64 approximate_size = 10;
inline void RegionHeartbeatRequest::clear_approximate_size() {
  approximate_size_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionHeartbeatRequest::approximate_size() const {
  // @@protoc_insertion_point(field_get:schedulerpb.RegionHeartbeatRequest.approximate_size)
  return approximate_size_;
}
inline void RegionHeartbeatRequest::set_approximate_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  approximate_size_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.RegionHeartbeatRequest.approximate_size)
}

// -------------------------------------------------------------------

// ChangePeer

// .metapb.Peer peer = 1;
inline bool ChangePeer::has_peer() const {
  return this != internal_default_instance() && peer_ != nullptr;
}
inline const ::metapb::Peer& ChangePeer::peer() const {
  const ::metapb::Peer* p = peer_;
  // @@protoc_insertion_point(field_get:schedulerpb.ChangePeer.peer)
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::Peer*>(
      &::metapb::_Peer_default_instance_);
}
inline ::metapb::Peer* ChangePeer::release_peer() {
  // @@protoc_insertion_point(field_release:schedulerpb.ChangePeer.peer)
  
  ::metapb::Peer* temp = peer_;
  peer_ = nullptr;
  return temp;
}
inline ::metapb::Peer* ChangePeer::mutable_peer() {
  
  if (peer_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::Peer>(GetArenaNoVirtual());
    peer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.ChangePeer.peer)
  return peer_;
}
inline void ChangePeer::set_allocated_peer(::metapb::Peer* peer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_);
  }
  if (peer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      peer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.ChangePeer.peer)
}

// .eraftpb.ConfChangeType change_type = 2;
inline void ChangePeer::clear_change_type() {
  change_type_ = 0;
}
inline ::eraftpb::ConfChangeType ChangePeer::change_type() const {
  // @@protoc_insertion_point(field_get:schedulerpb.ChangePeer.change_type)
  return static_cast< ::eraftpb::ConfChangeType >(change_type_);
}
inline void ChangePeer::set_change_type(::eraftpb::ConfChangeType value) {
  
  change_type_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.ChangePeer.change_type)
}

// -------------------------------------------------------------------

// TransferLeader

// .metapb.Peer peer = 1;
inline bool TransferLeader::has_peer() const {
  return this != internal_default_instance() && peer_ != nullptr;
}
inline const ::metapb::Peer& TransferLeader::peer() const {
  const ::metapb::Peer* p = peer_;
  // @@protoc_insertion_point(field_get:schedulerpb.TransferLeader.peer)
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::Peer*>(
      &::metapb::_Peer_default_instance_);
}
inline ::metapb::Peer* TransferLeader::release_peer() {
  // @@protoc_insertion_point(field_release:schedulerpb.TransferLeader.peer)
  
  ::metapb::Peer* temp = peer_;
  peer_ = nullptr;
  return temp;
}
inline ::metapb::Peer* TransferLeader::mutable_peer() {
  
  if (peer_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::Peer>(GetArenaNoVirtual());
    peer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.TransferLeader.peer)
  return peer_;
}
inline void TransferLeader::set_allocated_peer(::metapb::Peer* peer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_);
  }
  if (peer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      peer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.TransferLeader.peer)
}

// -------------------------------------------------------------------

// RegionHeartbeatResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool RegionHeartbeatResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void RegionHeartbeatResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& RegionHeartbeatResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.RegionHeartbeatResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* RegionHeartbeatResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.RegionHeartbeatResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* RegionHeartbeatResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.RegionHeartbeatResponse.header)
  return header_;
}
inline void RegionHeartbeatResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.RegionHeartbeatResponse.header)
}

// .schedulerpb.ChangePeer change_peer = 2;
inline bool RegionHeartbeatResponse::has_change_peer() const {
  return this != internal_default_instance() && change_peer_ != nullptr;
}
inline void RegionHeartbeatResponse::clear_change_peer() {
  if (GetArenaNoVirtual() == nullptr && change_peer_ != nullptr) {
    delete change_peer_;
  }
  change_peer_ = nullptr;
}
inline const ::schedulerpb::ChangePeer& RegionHeartbeatResponse::change_peer() const {
  const ::schedulerpb::ChangePeer* p = change_peer_;
  // @@protoc_insertion_point(field_get:schedulerpb.RegionHeartbeatResponse.change_peer)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ChangePeer*>(
      &::schedulerpb::_ChangePeer_default_instance_);
}
inline ::schedulerpb::ChangePeer* RegionHeartbeatResponse::release_change_peer() {
  // @@protoc_insertion_point(field_release:schedulerpb.RegionHeartbeatResponse.change_peer)
  
  ::schedulerpb::ChangePeer* temp = change_peer_;
  change_peer_ = nullptr;
  return temp;
}
inline ::schedulerpb::ChangePeer* RegionHeartbeatResponse::mutable_change_peer() {
  
  if (change_peer_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ChangePeer>(GetArenaNoVirtual());
    change_peer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.RegionHeartbeatResponse.change_peer)
  return change_peer_;
}
inline void RegionHeartbeatResponse::set_allocated_change_peer(::schedulerpb::ChangePeer* change_peer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete change_peer_;
  }
  if (change_peer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      change_peer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, change_peer, submessage_arena);
    }
    
  } else {
    
  }
  change_peer_ = change_peer;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.RegionHeartbeatResponse.change_peer)
}

// .schedulerpb.TransferLeader transfer_leader = 3;
inline bool RegionHeartbeatResponse::has_transfer_leader() const {
  return this != internal_default_instance() && transfer_leader_ != nullptr;
}
inline void RegionHeartbeatResponse::clear_transfer_leader() {
  if (GetArenaNoVirtual() == nullptr && transfer_leader_ != nullptr) {
    delete transfer_leader_;
  }
  transfer_leader_ = nullptr;
}
inline const ::schedulerpb::TransferLeader& RegionHeartbeatResponse::transfer_leader() const {
  const ::schedulerpb::TransferLeader* p = transfer_leader_;
  // @@protoc_insertion_point(field_get:schedulerpb.RegionHeartbeatResponse.transfer_leader)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::TransferLeader*>(
      &::schedulerpb::_TransferLeader_default_instance_);
}
inline ::schedulerpb::TransferLeader* RegionHeartbeatResponse::release_transfer_leader() {
  // @@protoc_insertion_point(field_release:schedulerpb.RegionHeartbeatResponse.transfer_leader)
  
  ::schedulerpb::TransferLeader* temp = transfer_leader_;
  transfer_leader_ = nullptr;
  return temp;
}
inline ::schedulerpb::TransferLeader* RegionHeartbeatResponse::mutable_transfer_leader() {
  
  if (transfer_leader_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::TransferLeader>(GetArenaNoVirtual());
    transfer_leader_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.RegionHeartbeatResponse.transfer_leader)
  return transfer_leader_;
}
inline void RegionHeartbeatResponse::set_allocated_transfer_leader(::schedulerpb::TransferLeader* transfer_leader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete transfer_leader_;
  }
  if (transfer_leader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      transfer_leader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transfer_leader, submessage_arena);
    }
    
  } else {
    
  }
  transfer_leader_ = transfer_leader;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.RegionHeartbeatResponse.transfer_leader)
}

// uint64 region_id = 4;
inline void RegionHeartbeatResponse::clear_region_id() {
  region_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionHeartbeatResponse::region_id() const {
  // @@protoc_insertion_point(field_get:schedulerpb.RegionHeartbeatResponse.region_id)
  return region_id_;
}
inline void RegionHeartbeatResponse::set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  region_id_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.RegionHeartbeatResponse.region_id)
}

// .metapb.RegionEpoch region_epoch = 5;
inline bool RegionHeartbeatResponse::has_region_epoch() const {
  return this != internal_default_instance() && region_epoch_ != nullptr;
}
inline const ::metapb::RegionEpoch& RegionHeartbeatResponse::region_epoch() const {
  const ::metapb::RegionEpoch* p = region_epoch_;
  // @@protoc_insertion_point(field_get:schedulerpb.RegionHeartbeatResponse.region_epoch)
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::RegionEpoch*>(
      &::metapb::_RegionEpoch_default_instance_);
}
inline ::metapb::RegionEpoch* RegionHeartbeatResponse::release_region_epoch() {
  // @@protoc_insertion_point(field_release:schedulerpb.RegionHeartbeatResponse.region_epoch)
  
  ::metapb::RegionEpoch* temp = region_epoch_;
  region_epoch_ = nullptr;
  return temp;
}
inline ::metapb::RegionEpoch* RegionHeartbeatResponse::mutable_region_epoch() {
  
  if (region_epoch_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::RegionEpoch>(GetArenaNoVirtual());
    region_epoch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.RegionHeartbeatResponse.region_epoch)
  return region_epoch_;
}
inline void RegionHeartbeatResponse::set_allocated_region_epoch(::metapb::RegionEpoch* region_epoch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_epoch_);
  }
  if (region_epoch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      region_epoch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_epoch, submessage_arena);
    }
    
  } else {
    
  }
  region_epoch_ = region_epoch;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.RegionHeartbeatResponse.region_epoch)
}

// .metapb.Peer target_peer = 6;
inline bool RegionHeartbeatResponse::has_target_peer() const {
  return this != internal_default_instance() && target_peer_ != nullptr;
}
inline const ::metapb::Peer& RegionHeartbeatResponse::target_peer() const {
  const ::metapb::Peer* p = target_peer_;
  // @@protoc_insertion_point(field_get:schedulerpb.RegionHeartbeatResponse.target_peer)
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::Peer*>(
      &::metapb::_Peer_default_instance_);
}
inline ::metapb::Peer* RegionHeartbeatResponse::release_target_peer() {
  // @@protoc_insertion_point(field_release:schedulerpb.RegionHeartbeatResponse.target_peer)
  
  ::metapb::Peer* temp = target_peer_;
  target_peer_ = nullptr;
  return temp;
}
inline ::metapb::Peer* RegionHeartbeatResponse::mutable_target_peer() {
  
  if (target_peer_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::Peer>(GetArenaNoVirtual());
    target_peer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.RegionHeartbeatResponse.target_peer)
  return target_peer_;
}
inline void RegionHeartbeatResponse::set_allocated_target_peer(::metapb::Peer* target_peer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_peer_);
  }
  if (target_peer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      target_peer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_peer, submessage_arena);
    }
    
  } else {
    
  }
  target_peer_ = target_peer;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.RegionHeartbeatResponse.target_peer)
}

// -------------------------------------------------------------------

// AskSplitRequest

// .schedulerpb.RequestHeader header = 1;
inline bool AskSplitRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void AskSplitRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& AskSplitRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.AskSplitRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* AskSplitRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.AskSplitRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* AskSplitRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.AskSplitRequest.header)
  return header_;
}
inline void AskSplitRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.AskSplitRequest.header)
}

// .metapb.Region region = 2;
inline bool AskSplitRequest::has_region() const {
  return this != internal_default_instance() && region_ != nullptr;
}
inline const ::metapb::Region& AskSplitRequest::region() const {
  const ::metapb::Region* p = region_;
  // @@protoc_insertion_point(field_get:schedulerpb.AskSplitRequest.region)
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::Region*>(
      &::metapb::_Region_default_instance_);
}
inline ::metapb::Region* AskSplitRequest::release_region() {
  // @@protoc_insertion_point(field_release:schedulerpb.AskSplitRequest.region)
  
  ::metapb::Region* temp = region_;
  region_ = nullptr;
  return temp;
}
inline ::metapb::Region* AskSplitRequest::mutable_region() {
  
  if (region_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::Region>(GetArenaNoVirtual());
    region_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.AskSplitRequest.region)
  return region_;
}
inline void AskSplitRequest::set_allocated_region(::metapb::Region* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_);
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    
  } else {
    
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.AskSplitRequest.region)
}

// -------------------------------------------------------------------

// AskSplitResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool AskSplitResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void AskSplitResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& AskSplitResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.AskSplitResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* AskSplitResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.AskSplitResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* AskSplitResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.AskSplitResponse.header)
  return header_;
}
inline void AskSplitResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.AskSplitResponse.header)
}

// uint64 new_region_id = 2;
inline void AskSplitResponse::clear_new_region_id() {
  new_region_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AskSplitResponse::new_region_id() const {
  // @@protoc_insertion_point(field_get:schedulerpb.AskSplitResponse.new_region_id)
  return new_region_id_;
}
inline void AskSplitResponse::set_new_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  new_region_id_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.AskSplitResponse.new_region_id)
}

// repeated uint64 new_peer_ids = 3;
inline int AskSplitResponse::new_peer_ids_size() const {
  return new_peer_ids_.size();
}
inline void AskSplitResponse::clear_new_peer_ids() {
  new_peer_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AskSplitResponse::new_peer_ids(int index) const {
  // @@protoc_insertion_point(field_get:schedulerpb.AskSplitResponse.new_peer_ids)
  return new_peer_ids_.Get(index);
}
inline void AskSplitResponse::set_new_peer_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  new_peer_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:schedulerpb.AskSplitResponse.new_peer_ids)
}
inline void AskSplitResponse::add_new_peer_ids(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  new_peer_ids_.Add(value);
  // @@protoc_insertion_point(field_add:schedulerpb.AskSplitResponse.new_peer_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
AskSplitResponse::new_peer_ids() const {
  // @@protoc_insertion_point(field_list:schedulerpb.AskSplitResponse.new_peer_ids)
  return new_peer_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
AskSplitResponse::mutable_new_peer_ids() {
  // @@protoc_insertion_point(field_mutable_list:schedulerpb.AskSplitResponse.new_peer_ids)
  return &new_peer_ids_;
}

// -------------------------------------------------------------------

// ReportSplitRequest

// .schedulerpb.RequestHeader header = 1;
inline bool ReportSplitRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void ReportSplitRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& ReportSplitRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.ReportSplitRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* ReportSplitRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.ReportSplitRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* ReportSplitRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.ReportSplitRequest.header)
  return header_;
}
inline void ReportSplitRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.ReportSplitRequest.header)
}

// .metapb.Region left = 2;
inline bool ReportSplitRequest::has_left() const {
  return this != internal_default_instance() && left_ != nullptr;
}
inline const ::metapb::Region& ReportSplitRequest::left() const {
  const ::metapb::Region* p = left_;
  // @@protoc_insertion_point(field_get:schedulerpb.ReportSplitRequest.left)
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::Region*>(
      &::metapb::_Region_default_instance_);
}
inline ::metapb::Region* ReportSplitRequest::release_left() {
  // @@protoc_insertion_point(field_release:schedulerpb.ReportSplitRequest.left)
  
  ::metapb::Region* temp = left_;
  left_ = nullptr;
  return temp;
}
inline ::metapb::Region* ReportSplitRequest::mutable_left() {
  
  if (left_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::Region>(GetArenaNoVirtual());
    left_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.ReportSplitRequest.left)
  return left_;
}
inline void ReportSplitRequest::set_allocated_left(::metapb::Region* left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_);
  }
  if (left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.ReportSplitRequest.left)
}

// .metapb.Region right = 3;
inline bool ReportSplitRequest::has_right() const {
  return this != internal_default_instance() && right_ != nullptr;
}
inline const ::metapb::Region& ReportSplitRequest::right() const {
  const ::metapb::Region* p = right_;
  // @@protoc_insertion_point(field_get:schedulerpb.ReportSplitRequest.right)
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::Region*>(
      &::metapb::_Region_default_instance_);
}
inline ::metapb::Region* ReportSplitRequest::release_right() {
  // @@protoc_insertion_point(field_release:schedulerpb.ReportSplitRequest.right)
  
  ::metapb::Region* temp = right_;
  right_ = nullptr;
  return temp;
}
inline ::metapb::Region* ReportSplitRequest::mutable_right() {
  
  if (right_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::Region>(GetArenaNoVirtual());
    right_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.ReportSplitRequest.right)
  return right_;
}
inline void ReportSplitRequest::set_allocated_right(::metapb::Region* right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_);
  }
  if (right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.ReportSplitRequest.right)
}

// -------------------------------------------------------------------

// ReportSplitResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool ReportSplitResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void ReportSplitResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& ReportSplitResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.ReportSplitResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* ReportSplitResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.ReportSplitResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* ReportSplitResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.ReportSplitResponse.header)
  return header_;
}
inline void ReportSplitResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.ReportSplitResponse.header)
}

// -------------------------------------------------------------------

// SplitID

// uint64 new_region_id = 1;
inline void SplitID::clear_new_region_id() {
  new_region_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SplitID::new_region_id() const {
  // @@protoc_insertion_point(field_get:schedulerpb.SplitID.new_region_id)
  return new_region_id_;
}
inline void SplitID::set_new_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  new_region_id_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.SplitID.new_region_id)
}

// repeated uint64 new_peer_ids = 2;
inline int SplitID::new_peer_ids_size() const {
  return new_peer_ids_.size();
}
inline void SplitID::clear_new_peer_ids() {
  new_peer_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SplitID::new_peer_ids(int index) const {
  // @@protoc_insertion_point(field_get:schedulerpb.SplitID.new_peer_ids)
  return new_peer_ids_.Get(index);
}
inline void SplitID::set_new_peer_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  new_peer_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:schedulerpb.SplitID.new_peer_ids)
}
inline void SplitID::add_new_peer_ids(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  new_peer_ids_.Add(value);
  // @@protoc_insertion_point(field_add:schedulerpb.SplitID.new_peer_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
SplitID::new_peer_ids() const {
  // @@protoc_insertion_point(field_list:schedulerpb.SplitID.new_peer_ids)
  return new_peer_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
SplitID::mutable_new_peer_ids() {
  // @@protoc_insertion_point(field_mutable_list:schedulerpb.SplitID.new_peer_ids)
  return &new_peer_ids_;
}

// -------------------------------------------------------------------

// TimeInterval

// uint64 start_timestamp = 1;
inline void TimeInterval::clear_start_timestamp() {
  start_timestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TimeInterval::start_timestamp() const {
  // @@protoc_insertion_point(field_get:schedulerpb.TimeInterval.start_timestamp)
  return start_timestamp_;
}
inline void TimeInterval::set_start_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  start_timestamp_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.TimeInterval.start_timestamp)
}

// uint64 end_timestamp = 2;
inline void TimeInterval::clear_end_timestamp() {
  end_timestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TimeInterval::end_timestamp() const {
  // @@protoc_insertion_point(field_get:schedulerpb.TimeInterval.end_timestamp)
  return end_timestamp_;
}
inline void TimeInterval::set_end_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  end_timestamp_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.TimeInterval.end_timestamp)
}

// -------------------------------------------------------------------

// RecordPair

// string key = 1;
inline void RecordPair::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RecordPair::key() const {
  // @@protoc_insertion_point(field_get:schedulerpb.RecordPair.key)
  return key_.GetNoArena();
}
inline void RecordPair::set_key(const std::string& value) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schedulerpb.RecordPair.key)
}
inline void RecordPair::set_key(std::string&& value) {
  
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:schedulerpb.RecordPair.key)
}
inline void RecordPair::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schedulerpb.RecordPair.key)
}
inline void RecordPair::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schedulerpb.RecordPair.key)
}
inline std::string* RecordPair::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:schedulerpb.RecordPair.key)
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RecordPair::release_key() {
  // @@protoc_insertion_point(field_release:schedulerpb.RecordPair.key)
  
  return key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RecordPair::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.RecordPair.key)
}

// uint64 value = 2;
inline void RecordPair::clear_value() {
  value_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RecordPair::value() const {
  // @@protoc_insertion_point(field_get:schedulerpb.RecordPair.value)
  return value_;
}
inline void RecordPair::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.RecordPair.value)
}

// -------------------------------------------------------------------

// StoreStats

// uint64 store_id = 1;
inline void StoreStats::clear_store_id() {
  store_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreStats::store_id() const {
  // @@protoc_insertion_point(field_get:schedulerpb.StoreStats.store_id)
  return store_id_;
}
inline void StoreStats::set_store_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  store_id_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.StoreStats.store_id)
}

// uint64 capacity = 2;
inline void StoreStats::clear_capacity() {
  capacity_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreStats::capacity() const {
  // @@protoc_insertion_point(field_get:schedulerpb.StoreStats.capacity)
  return capacity_;
}
inline void StoreStats::set_capacity(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  capacity_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.StoreStats.capacity)
}

// uint64 available = 3;
inline void StoreStats::clear_available() {
  available_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreStats::available() const {
  // @@protoc_insertion_point(field_get:schedulerpb.StoreStats.available)
  return available_;
}
inline void StoreStats::set_available(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  available_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.StoreStats.available)
}

// uint32 region_count = 4;
inline void StoreStats::clear_region_count() {
  region_count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StoreStats::region_count() const {
  // @@protoc_insertion_point(field_get:schedulerpb.StoreStats.region_count)
  return region_count_;
}
inline void StoreStats::set_region_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  region_count_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.StoreStats.region_count)
}

// uint32 sending_snap_count = 5;
inline void StoreStats::clear_sending_snap_count() {
  sending_snap_count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StoreStats::sending_snap_count() const {
  // @@protoc_insertion_point(field_get:schedulerpb.StoreStats.sending_snap_count)
  return sending_snap_count_;
}
inline void StoreStats::set_sending_snap_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sending_snap_count_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.StoreStats.sending_snap_count)
}

// uint32 receiving_snap_count = 6;
inline void StoreStats::clear_receiving_snap_count() {
  receiving_snap_count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StoreStats::receiving_snap_count() const {
  // @@protoc_insertion_point(field_get:schedulerpb.StoreStats.receiving_snap_count)
  return receiving_snap_count_;
}
inline void StoreStats::set_receiving_snap_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  receiving_snap_count_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.StoreStats.receiving_snap_count)
}

// uint32 start_time = 7;
inline void StoreStats::clear_start_time() {
  start_time_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StoreStats::start_time() const {
  // @@protoc_insertion_point(field_get:schedulerpb.StoreStats.start_time)
  return start_time_;
}
inline void StoreStats::set_start_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  start_time_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.StoreStats.start_time)
}

// uint32 applying_snap_count = 8;
inline void StoreStats::clear_applying_snap_count() {
  applying_snap_count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StoreStats::applying_snap_count() const {
  // @@protoc_insertion_point(field_get:schedulerpb.StoreStats.applying_snap_count)
  return applying_snap_count_;
}
inline void StoreStats::set_applying_snap_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  applying_snap_count_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.StoreStats.applying_snap_count)
}

// bool is_busy = 9;
inline void StoreStats::clear_is_busy() {
  is_busy_ = false;
}
inline bool StoreStats::is_busy() const {
  // @@protoc_insertion_point(field_get:schedulerpb.StoreStats.is_busy)
  return is_busy_;
}
inline void StoreStats::set_is_busy(bool value) {
  
  is_busy_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.StoreStats.is_busy)
}

// uint64 used_size = 10;
inline void StoreStats::clear_used_size() {
  used_size_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreStats::used_size() const {
  // @@protoc_insertion_point(field_get:schedulerpb.StoreStats.used_size)
  return used_size_;
}
inline void StoreStats::set_used_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  used_size_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.StoreStats.used_size)
}

// .schedulerpb.TimeInterval interval = 15;
inline bool StoreStats::has_interval() const {
  return this != internal_default_instance() && interval_ != nullptr;
}
inline void StoreStats::clear_interval() {
  if (GetArenaNoVirtual() == nullptr && interval_ != nullptr) {
    delete interval_;
  }
  interval_ = nullptr;
}
inline const ::schedulerpb::TimeInterval& StoreStats::interval() const {
  const ::schedulerpb::TimeInterval* p = interval_;
  // @@protoc_insertion_point(field_get:schedulerpb.StoreStats.interval)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::TimeInterval*>(
      &::schedulerpb::_TimeInterval_default_instance_);
}
inline ::schedulerpb::TimeInterval* StoreStats::release_interval() {
  // @@protoc_insertion_point(field_release:schedulerpb.StoreStats.interval)
  
  ::schedulerpb::TimeInterval* temp = interval_;
  interval_ = nullptr;
  return temp;
}
inline ::schedulerpb::TimeInterval* StoreStats::mutable_interval() {
  
  if (interval_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::TimeInterval>(GetArenaNoVirtual());
    interval_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.StoreStats.interval)
  return interval_;
}
inline void StoreStats::set_allocated_interval(::schedulerpb::TimeInterval* interval) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete interval_;
  }
  if (interval) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interval, submessage_arena);
    }
    
  } else {
    
  }
  interval_ = interval;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.StoreStats.interval)
}

// repeated .schedulerpb.RecordPair cpu_usages = 16;
inline int StoreStats::cpu_usages_size() const {
  return cpu_usages_.size();
}
inline void StoreStats::clear_cpu_usages() {
  cpu_usages_.Clear();
}
inline ::schedulerpb::RecordPair* StoreStats::mutable_cpu_usages(int index) {
  // @@protoc_insertion_point(field_mutable:schedulerpb.StoreStats.cpu_usages)
  return cpu_usages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair >*
StoreStats::mutable_cpu_usages() {
  // @@protoc_insertion_point(field_mutable_list:schedulerpb.StoreStats.cpu_usages)
  return &cpu_usages_;
}
inline const ::schedulerpb::RecordPair& StoreStats::cpu_usages(int index) const {
  // @@protoc_insertion_point(field_get:schedulerpb.StoreStats.cpu_usages)
  return cpu_usages_.Get(index);
}
inline ::schedulerpb::RecordPair* StoreStats::add_cpu_usages() {
  // @@protoc_insertion_point(field_add:schedulerpb.StoreStats.cpu_usages)
  return cpu_usages_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair >&
StoreStats::cpu_usages() const {
  // @@protoc_insertion_point(field_list:schedulerpb.StoreStats.cpu_usages)
  return cpu_usages_;
}

// repeated .schedulerpb.RecordPair read_io_rates = 17;
inline int StoreStats::read_io_rates_size() const {
  return read_io_rates_.size();
}
inline void StoreStats::clear_read_io_rates() {
  read_io_rates_.Clear();
}
inline ::schedulerpb::RecordPair* StoreStats::mutable_read_io_rates(int index) {
  // @@protoc_insertion_point(field_mutable:schedulerpb.StoreStats.read_io_rates)
  return read_io_rates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair >*
StoreStats::mutable_read_io_rates() {
  // @@protoc_insertion_point(field_mutable_list:schedulerpb.StoreStats.read_io_rates)
  return &read_io_rates_;
}
inline const ::schedulerpb::RecordPair& StoreStats::read_io_rates(int index) const {
  // @@protoc_insertion_point(field_get:schedulerpb.StoreStats.read_io_rates)
  return read_io_rates_.Get(index);
}
inline ::schedulerpb::RecordPair* StoreStats::add_read_io_rates() {
  // @@protoc_insertion_point(field_add:schedulerpb.StoreStats.read_io_rates)
  return read_io_rates_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair >&
StoreStats::read_io_rates() const {
  // @@protoc_insertion_point(field_list:schedulerpb.StoreStats.read_io_rates)
  return read_io_rates_;
}

// repeated .schedulerpb.RecordPair write_io_rates = 18;
inline int StoreStats::write_io_rates_size() const {
  return write_io_rates_.size();
}
inline void StoreStats::clear_write_io_rates() {
  write_io_rates_.Clear();
}
inline ::schedulerpb::RecordPair* StoreStats::mutable_write_io_rates(int index) {
  // @@protoc_insertion_point(field_mutable:schedulerpb.StoreStats.write_io_rates)
  return write_io_rates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair >*
StoreStats::mutable_write_io_rates() {
  // @@protoc_insertion_point(field_mutable_list:schedulerpb.StoreStats.write_io_rates)
  return &write_io_rates_;
}
inline const ::schedulerpb::RecordPair& StoreStats::write_io_rates(int index) const {
  // @@protoc_insertion_point(field_get:schedulerpb.StoreStats.write_io_rates)
  return write_io_rates_.Get(index);
}
inline ::schedulerpb::RecordPair* StoreStats::add_write_io_rates() {
  // @@protoc_insertion_point(field_add:schedulerpb.StoreStats.write_io_rates)
  return write_io_rates_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair >&
StoreStats::write_io_rates() const {
  // @@protoc_insertion_point(field_list:schedulerpb.StoreStats.write_io_rates)
  return write_io_rates_;
}

// repeated .schedulerpb.RecordPair op_latencies = 19;
inline int StoreStats::op_latencies_size() const {
  return op_latencies_.size();
}
inline void StoreStats::clear_op_latencies() {
  op_latencies_.Clear();
}
inline ::schedulerpb::RecordPair* StoreStats::mutable_op_latencies(int index) {
  // @@protoc_insertion_point(field_mutable:schedulerpb.StoreStats.op_latencies)
  return op_latencies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair >*
StoreStats::mutable_op_latencies() {
  // @@protoc_insertion_point(field_mutable_list:schedulerpb.StoreStats.op_latencies)
  return &op_latencies_;
}
inline const ::schedulerpb::RecordPair& StoreStats::op_latencies(int index) const {
  // @@protoc_insertion_point(field_get:schedulerpb.StoreStats.op_latencies)
  return op_latencies_.Get(index);
}
inline ::schedulerpb::RecordPair* StoreStats::add_op_latencies() {
  // @@protoc_insertion_point(field_add:schedulerpb.StoreStats.op_latencies)
  return op_latencies_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedulerpb::RecordPair >&
StoreStats::op_latencies() const {
  // @@protoc_insertion_point(field_list:schedulerpb.StoreStats.op_latencies)
  return op_latencies_;
}

// -------------------------------------------------------------------

// StoreHeartbeatRequest

// .schedulerpb.RequestHeader header = 1;
inline bool StoreHeartbeatRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void StoreHeartbeatRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& StoreHeartbeatRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.StoreHeartbeatRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* StoreHeartbeatRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.StoreHeartbeatRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* StoreHeartbeatRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.StoreHeartbeatRequest.header)
  return header_;
}
inline void StoreHeartbeatRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.StoreHeartbeatRequest.header)
}

// .schedulerpb.StoreStats stats = 2;
inline bool StoreHeartbeatRequest::has_stats() const {
  return this != internal_default_instance() && stats_ != nullptr;
}
inline void StoreHeartbeatRequest::clear_stats() {
  if (GetArenaNoVirtual() == nullptr && stats_ != nullptr) {
    delete stats_;
  }
  stats_ = nullptr;
}
inline const ::schedulerpb::StoreStats& StoreHeartbeatRequest::stats() const {
  const ::schedulerpb::StoreStats* p = stats_;
  // @@protoc_insertion_point(field_get:schedulerpb.StoreHeartbeatRequest.stats)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::StoreStats*>(
      &::schedulerpb::_StoreStats_default_instance_);
}
inline ::schedulerpb::StoreStats* StoreHeartbeatRequest::release_stats() {
  // @@protoc_insertion_point(field_release:schedulerpb.StoreHeartbeatRequest.stats)
  
  ::schedulerpb::StoreStats* temp = stats_;
  stats_ = nullptr;
  return temp;
}
inline ::schedulerpb::StoreStats* StoreHeartbeatRequest::mutable_stats() {
  
  if (stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::StoreStats>(GetArenaNoVirtual());
    stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.StoreHeartbeatRequest.stats)
  return stats_;
}
inline void StoreHeartbeatRequest::set_allocated_stats(::schedulerpb::StoreStats* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete stats_;
  }
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.StoreHeartbeatRequest.stats)
}

// -------------------------------------------------------------------

// StoreHeartbeatResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool StoreHeartbeatResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void StoreHeartbeatResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& StoreHeartbeatResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.StoreHeartbeatResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* StoreHeartbeatResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.StoreHeartbeatResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* StoreHeartbeatResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.StoreHeartbeatResponse.header)
  return header_;
}
inline void StoreHeartbeatResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.StoreHeartbeatResponse.header)
}

// -------------------------------------------------------------------

// ScatterRegionRequest

// .schedulerpb.RequestHeader header = 1;
inline bool ScatterRegionRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void ScatterRegionRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& ScatterRegionRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.ScatterRegionRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* ScatterRegionRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.ScatterRegionRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* ScatterRegionRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.ScatterRegionRequest.header)
  return header_;
}
inline void ScatterRegionRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.ScatterRegionRequest.header)
}

// uint64 region_id = 2;
inline void ScatterRegionRequest::clear_region_id() {
  region_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ScatterRegionRequest::region_id() const {
  // @@protoc_insertion_point(field_get:schedulerpb.ScatterRegionRequest.region_id)
  return region_id_;
}
inline void ScatterRegionRequest::set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  region_id_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.ScatterRegionRequest.region_id)
}

// .metapb.Region region = 3;
inline bool ScatterRegionRequest::has_region() const {
  return this != internal_default_instance() && region_ != nullptr;
}
inline const ::metapb::Region& ScatterRegionRequest::region() const {
  const ::metapb::Region* p = region_;
  // @@protoc_insertion_point(field_get:schedulerpb.ScatterRegionRequest.region)
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::Region*>(
      &::metapb::_Region_default_instance_);
}
inline ::metapb::Region* ScatterRegionRequest::release_region() {
  // @@protoc_insertion_point(field_release:schedulerpb.ScatterRegionRequest.region)
  
  ::metapb::Region* temp = region_;
  region_ = nullptr;
  return temp;
}
inline ::metapb::Region* ScatterRegionRequest::mutable_region() {
  
  if (region_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::Region>(GetArenaNoVirtual());
    region_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.ScatterRegionRequest.region)
  return region_;
}
inline void ScatterRegionRequest::set_allocated_region(::metapb::Region* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_);
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    
  } else {
    
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.ScatterRegionRequest.region)
}

// .metapb.Peer leader = 4;
inline bool ScatterRegionRequest::has_leader() const {
  return this != internal_default_instance() && leader_ != nullptr;
}
inline const ::metapb::Peer& ScatterRegionRequest::leader() const {
  const ::metapb::Peer* p = leader_;
  // @@protoc_insertion_point(field_get:schedulerpb.ScatterRegionRequest.leader)
  return p != nullptr ? *p : *reinterpret_cast<const ::metapb::Peer*>(
      &::metapb::_Peer_default_instance_);
}
inline ::metapb::Peer* ScatterRegionRequest::release_leader() {
  // @@protoc_insertion_point(field_release:schedulerpb.ScatterRegionRequest.leader)
  
  ::metapb::Peer* temp = leader_;
  leader_ = nullptr;
  return temp;
}
inline ::metapb::Peer* ScatterRegionRequest::mutable_leader() {
  
  if (leader_ == nullptr) {
    auto* p = CreateMaybeMessage<::metapb::Peer>(GetArenaNoVirtual());
    leader_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.ScatterRegionRequest.leader)
  return leader_;
}
inline void ScatterRegionRequest::set_allocated_leader(::metapb::Peer* leader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader_);
  }
  if (leader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      leader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leader, submessage_arena);
    }
    
  } else {
    
  }
  leader_ = leader;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.ScatterRegionRequest.leader)
}

// -------------------------------------------------------------------

// ScatterRegionResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool ScatterRegionResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void ScatterRegionResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& ScatterRegionResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.ScatterRegionResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* ScatterRegionResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.ScatterRegionResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* ScatterRegionResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.ScatterRegionResponse.header)
  return header_;
}
inline void ScatterRegionResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.ScatterRegionResponse.header)
}

// -------------------------------------------------------------------

// GetGCSafePointRequest

// .schedulerpb.RequestHeader header = 1;
inline bool GetGCSafePointRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetGCSafePointRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& GetGCSafePointRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetGCSafePointRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* GetGCSafePointRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetGCSafePointRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* GetGCSafePointRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetGCSafePointRequest.header)
  return header_;
}
inline void GetGCSafePointRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetGCSafePointRequest.header)
}

// -------------------------------------------------------------------

// GetGCSafePointResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool GetGCSafePointResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetGCSafePointResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& GetGCSafePointResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetGCSafePointResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* GetGCSafePointResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetGCSafePointResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* GetGCSafePointResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetGCSafePointResponse.header)
  return header_;
}
inline void GetGCSafePointResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetGCSafePointResponse.header)
}

// uint64 safe_point = 2;
inline void GetGCSafePointResponse::clear_safe_point() {
  safe_point_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetGCSafePointResponse::safe_point() const {
  // @@protoc_insertion_point(field_get:schedulerpb.GetGCSafePointResponse.safe_point)
  return safe_point_;
}
inline void GetGCSafePointResponse::set_safe_point(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  safe_point_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.GetGCSafePointResponse.safe_point)
}

// -------------------------------------------------------------------

// UpdateGCSafePointRequest

// .schedulerpb.RequestHeader header = 1;
inline bool UpdateGCSafePointRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void UpdateGCSafePointRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& UpdateGCSafePointRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.UpdateGCSafePointRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* UpdateGCSafePointRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.UpdateGCSafePointRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* UpdateGCSafePointRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.UpdateGCSafePointRequest.header)
  return header_;
}
inline void UpdateGCSafePointRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.UpdateGCSafePointRequest.header)
}

// uint64 safe_point = 2;
inline void UpdateGCSafePointRequest::clear_safe_point() {
  safe_point_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UpdateGCSafePointRequest::safe_point() const {
  // @@protoc_insertion_point(field_get:schedulerpb.UpdateGCSafePointRequest.safe_point)
  return safe_point_;
}
inline void UpdateGCSafePointRequest::set_safe_point(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  safe_point_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.UpdateGCSafePointRequest.safe_point)
}

// -------------------------------------------------------------------

// UpdateGCSafePointResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool UpdateGCSafePointResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void UpdateGCSafePointResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& UpdateGCSafePointResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.UpdateGCSafePointResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* UpdateGCSafePointResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.UpdateGCSafePointResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* UpdateGCSafePointResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.UpdateGCSafePointResponse.header)
  return header_;
}
inline void UpdateGCSafePointResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.UpdateGCSafePointResponse.header)
}

// uint64 new_safe_point = 2;
inline void UpdateGCSafePointResponse::clear_new_safe_point() {
  new_safe_point_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UpdateGCSafePointResponse::new_safe_point() const {
  // @@protoc_insertion_point(field_get:schedulerpb.UpdateGCSafePointResponse.new_safe_point)
  return new_safe_point_;
}
inline void UpdateGCSafePointResponse::set_new_safe_point(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  new_safe_point_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.UpdateGCSafePointResponse.new_safe_point)
}

// -------------------------------------------------------------------

// GetOperatorRequest

// .schedulerpb.RequestHeader header = 1;
inline bool GetOperatorRequest::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetOperatorRequest::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::RequestHeader& GetOperatorRequest::header() const {
  const ::schedulerpb::RequestHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetOperatorRequest.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::RequestHeader*>(
      &::schedulerpb::_RequestHeader_default_instance_);
}
inline ::schedulerpb::RequestHeader* GetOperatorRequest::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetOperatorRequest.header)
  
  ::schedulerpb::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::RequestHeader* GetOperatorRequest::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::RequestHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetOperatorRequest.header)
  return header_;
}
inline void GetOperatorRequest::set_allocated_header(::schedulerpb::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetOperatorRequest.header)
}

// uint64 region_id = 2;
inline void GetOperatorRequest::clear_region_id() {
  region_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetOperatorRequest::region_id() const {
  // @@protoc_insertion_point(field_get:schedulerpb.GetOperatorRequest.region_id)
  return region_id_;
}
inline void GetOperatorRequest::set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  region_id_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.GetOperatorRequest.region_id)
}

// -------------------------------------------------------------------

// GetOperatorResponse

// .schedulerpb.ResponseHeader header = 1;
inline bool GetOperatorResponse::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void GetOperatorResponse::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::schedulerpb::ResponseHeader& GetOperatorResponse::header() const {
  const ::schedulerpb::ResponseHeader* p = header_;
  // @@protoc_insertion_point(field_get:schedulerpb.GetOperatorResponse.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::schedulerpb::ResponseHeader*>(
      &::schedulerpb::_ResponseHeader_default_instance_);
}
inline ::schedulerpb::ResponseHeader* GetOperatorResponse::release_header() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetOperatorResponse.header)
  
  ::schedulerpb::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::schedulerpb::ResponseHeader* GetOperatorResponse::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::schedulerpb::ResponseHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetOperatorResponse.header)
  return header_;
}
inline void GetOperatorResponse::set_allocated_header(::schedulerpb::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetOperatorResponse.header)
}

// uint64 region_id = 2;
inline void GetOperatorResponse::clear_region_id() {
  region_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetOperatorResponse::region_id() const {
  // @@protoc_insertion_point(field_get:schedulerpb.GetOperatorResponse.region_id)
  return region_id_;
}
inline void GetOperatorResponse::set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  region_id_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.GetOperatorResponse.region_id)
}

// bytes desc = 3;
inline void GetOperatorResponse::clear_desc() {
  desc_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GetOperatorResponse::desc() const {
  // @@protoc_insertion_point(field_get:schedulerpb.GetOperatorResponse.desc)
  return desc_.GetNoArena();
}
inline void GetOperatorResponse::set_desc(const std::string& value) {
  
  desc_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schedulerpb.GetOperatorResponse.desc)
}
inline void GetOperatorResponse::set_desc(std::string&& value) {
  
  desc_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:schedulerpb.GetOperatorResponse.desc)
}
inline void GetOperatorResponse::set_desc(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  desc_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schedulerpb.GetOperatorResponse.desc)
}
inline void GetOperatorResponse::set_desc(const void* value, size_t size) {
  
  desc_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schedulerpb.GetOperatorResponse.desc)
}
inline std::string* GetOperatorResponse::mutable_desc() {
  
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetOperatorResponse.desc)
  return desc_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetOperatorResponse::release_desc() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetOperatorResponse.desc)
  
  return desc_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetOperatorResponse::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  desc_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetOperatorResponse.desc)
}

// .schedulerpb.OperatorStatus status = 4;
inline void GetOperatorResponse::clear_status() {
  status_ = 0;
}
inline ::schedulerpb::OperatorStatus GetOperatorResponse::status() const {
  // @@protoc_insertion_point(field_get:schedulerpb.GetOperatorResponse.status)
  return static_cast< ::schedulerpb::OperatorStatus >(status_);
}
inline void GetOperatorResponse::set_status(::schedulerpb::OperatorStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:schedulerpb.GetOperatorResponse.status)
}

// bytes kind = 5;
inline void GetOperatorResponse::clear_kind() {
  kind_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GetOperatorResponse::kind() const {
  // @@protoc_insertion_point(field_get:schedulerpb.GetOperatorResponse.kind)
  return kind_.GetNoArena();
}
inline void GetOperatorResponse::set_kind(const std::string& value) {
  
  kind_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:schedulerpb.GetOperatorResponse.kind)
}
inline void GetOperatorResponse::set_kind(std::string&& value) {
  
  kind_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:schedulerpb.GetOperatorResponse.kind)
}
inline void GetOperatorResponse::set_kind(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  kind_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:schedulerpb.GetOperatorResponse.kind)
}
inline void GetOperatorResponse::set_kind(const void* value, size_t size) {
  
  kind_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:schedulerpb.GetOperatorResponse.kind)
}
inline std::string* GetOperatorResponse::mutable_kind() {
  
  // @@protoc_insertion_point(field_mutable:schedulerpb.GetOperatorResponse.kind)
  return kind_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetOperatorResponse::release_kind() {
  // @@protoc_insertion_point(field_release:schedulerpb.GetOperatorResponse.kind)
  
  return kind_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetOperatorResponse::set_allocated_kind(std::string* kind) {
  if (kind != nullptr) {
    
  } else {
    
  }
  kind_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kind);
  // @@protoc_insertion_point(field_set_allocated:schedulerpb.GetOperatorResponse.kind)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace schedulerpb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::schedulerpb::ErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::schedulerpb::ErrorType>() {
  return ::schedulerpb::ErrorType_descriptor();
}
template <> struct is_proto_enum< ::schedulerpb::OperatorStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::schedulerpb::OperatorStatus>() {
  return ::schedulerpb::OperatorStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_schedulerpb_2eproto
